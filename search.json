[{"path":"https://danymukesha.github.io/BioGA/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 Dany Mukesha Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":[]},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"installation","dir":"Articles","previous_headings":"Getting Started","what":"Installation","title":"Introduction to BioGA","text":"install package, start R (version “4.4”) enter: can also install package directly GitHub using devtools package: simplified example, illustrated usage BioGA genetic algorithm optimization context high throughput genomic data analysis. showcased interoperability Bioconductor classes, demonstrating genetic algorithm optimization can integrated existing genomics pipelines improve analysis interpretation. demonstrated usage BioGA context selecting best combination genes predicting certain trait, disease susceptibility.","code":"if (!require(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\")  # The following initializes usage of Bioc devel BiocManager::install(version='devel')  BiocManager::install(pkgs = \"BioGA\", version = \"devel\", force = TRUE) devtools::install_github(\"danymukesha/BioGA\")"},{"path":[]},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"algorithmic-framework","dir":"Articles","previous_headings":"Getting Started > Implementation","what":"Algorithmic Framework","title":"Introduction to BioGA","text":"core BioGA lies modified version NSGA-II algorithm, tailored specifically demands high-throughput genomic data. Traditional implementations NSGA-II operate generic problem domains, BioGA introduces biologically informed heuristics multiple stages evolutionary cycle better capture structure genomic data. initialization mutation, step algorithm leverages gene-level relationships maintain biological plausibility. notable innovation multi-objective fitness function, combines classification accuracy gene set sparsity. adjusting tunable parameter α, users can customize trade-depending whether interpretability (fewer genes) predictive power important application. fitness evaluation parallelized using OpenMP, allowing fast computation even large populations datasets. C++ snippet included demonstrates fitness evaluation computes three key metrics; accuracy, sparsity, weighted combination guide evolutionary selection. Importantly, performance-critical computation written native C++ Rcpp, yielding speed memory efficiency.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"software-architecture","dir":"Articles","previous_headings":"Getting Started > Implementation","what":"Software Architecture","title":"Introduction to BioGA","text":"BioGA’s layered architecture designed modularity, scalability, user accessibility. top layer, clean R/Bioconductor interface makes tool accessible bioinformatics community, providing standard S4 object support integration SummarizedExperiment ExpressionSet classes. enables seamless incorporation existing genomic analysis pipelines. middle layer, written C++ using RcppArmadillo, provides computational engine. layer fully parallelized using RcppParallel OpenMP, enabling users exploit multi-core architectures. Even commodity hardware, BioGA can outperform many existing tools due efficient backend. Finally, architecture connects biological databases annotation frameworks, including STRINGdb, WGCNA, KEGG pathways. integration ensures evolutionary operators mutation selection biologically informed rather purely random, critical advancement traditional GA models ignore gene-gene relationships.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"biologically-informed-operators","dir":"Articles","previous_headings":"Getting Started > Implementation","what":"Biologically Informed Operators","title":"Introduction to BioGA","text":"standout feature BioGA ability incorporate biological knowledge directly evolutionary process. Instead relying purely stochastic operations, BioGA uses known gene interaction networks guide mutations initialize populations. example, genes selected mutation can constrained lie within co-expression neighborhoods, reducing likelihood generating biologically implausible candidates. Similarly, cluster-based initialization based WGCNA modules ensures starting populations contain co-regulated gene sets. suddenly improves convergence speed algorithm increases biological interpretability final solution. selection, pathway-aware heuristics prioritize gene sets enriched relevant signaling pathways, promoting results accurate biologically meaningful. biologically inspired innovations make BioGA particularly suited applications precision medicine, model interpretability biological validity just important statistical performance. Figure 1: Workflow BioGA algorithm. Gene expression data, supported gene networks pathways (e.g., STRINGdb, WGCNA), initiates biologically informed population initialization. feeds modified NSGA-II evolutionary algorithm featuring multi-objective fitness function (balancing classification accuracy gene set sparsity) parallelized C++ backend (Rcpp, OpenMP) efficiency. result optimized gene signatures clustering models preserve biological plausibility interpretability. See Section Implementation details.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"advantages-over-existing-approaches","dir":"Articles","previous_headings":"Getting Started > Implementation","what":"Advantages Over Existing Approaches","title":"Introduction to BioGA","text":"BioGA represents significant leap forward applying genetic algorithms genomic data analysis. multi-objective optimization capability allows researchers visualize full spectrum solutions; ranging sparse, interpretable models dense, highly predictive ones. crucial contexts like biomarker discovery feature selection, trade-offs simplicity accuracy must carefully balanced. Additionally, BioGA’s C++ backend parallel processing support dramatically outperform R-based tools like GA, genalg, rgenoud. leveraging OpenMP memory-efficient data structures, processes genome-wide datasets minutes rather hours. efficiency unlocks new use cases iterative tuning, real-time interactive analysis, single-cell datasets hundreds thousands cells. Equally important BioGA’s biological relevance. embedding knowledge gene networks pathways optimization process, ensures discovered features predictive also interpretable within biological context. particularly valuable downstream tasks like experimental validation, clinical translation, pathway enrichment analysis.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"comparison-with-related-tools","dir":"Articles","previous_headings":"Getting Started > Implementation","what":"Comparison with Related Tools","title":"Introduction to BioGA","text":"put BioGA’s capabilities perspective, Table 2 compares features common GA packages. Notably, BioGA package supports four critical features: multi-objective optimization, biological constraints, parallel computing, Bioconductor integration. tools offer parallelism flexible fitness functions, none combine domain-specific biological awareness necessary modern genomics. unique positioning makes BioGA especially well-suited bioinformatics labs seeking robust, scalable, biologically informed optimization frameworks.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"limitations-and-future-directions","dir":"Articles","previous_headings":"Getting Started > Implementation","what":"Limitations and Future Directions","title":"Introduction to BioGA","text":"Despite strengths, BioGA several current limitations present opportunities future work. One area GPU acceleration. Preliminary CUDA support shows promising speedups fitness evaluation function, development enable real-time genomic optimization large-scale datasets clinical settings. Another direction multi-omics integration. BioGA currently supports gene expression data, future versions allow users integrate methylation, copy number variation, proteomics data additional constraints objectives. enable comprehensive molecular profiling holistic biomarker discovery. Lastly, cloud-native deployment via containerized workflows (Docker, Singularity) development, along prebuilt pipelines AWS Batch Google Cloud Life Sciences. allow BioGA scale efficiently across cloud computing resources larger collaborative projects high-throughput pipelines. BioGA addresses pressing need modern genomics: ability perform efficient, biologically relevant optimization high-dimensional data. combining high-performance C++ core, multi-objective optimization via NSGA-II, integration biological knowledge bases, BioGA empowers researchers identify meaningful, interpretable solutions complex problems like biomarker discovery, feature selection, single-cell clustering. Unlike traditional GAs, BioGA black-box optimizer; deeply embedded biological reasoning. design philosophy ensures solutions computationally optimal also scientifically actionable. Whether used academic research, translational bioinformatics, personalized medicine, BioGA offers powerful framework tailored demands modern genomic data.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"overview","dir":"Articles","previous_headings":"Getting Started","what":"Overview","title":"Introduction to BioGA","text":"Genomic data generally refers genetic information stored DNA organism. DNA molecules basically mmade sequence nucleotides (adenine, thymine, cytosine, guanine). genetic information likely provides clear understanding various biological processes, gene expression, genetic variation, evolutionary relationships. context, genomic data consist gene expression profiles measured across different individuals (e.g., patients). : row genomic_data matrix represents gene, column represents patient sample. Values matrix represent expression levels gene patient sample. example genomic data, let’s consider table similar following: table , row represents gene (genomic feature), column represents sample. values matrix represent measurement gene expression, mRNA levels protein abundance, sample. instance, value 0.1 “Sample 1” Gene1 indicates expression level Gene1 “Sample 1”. Similarly, value 2.2 “Sample 2” Gene3 indicates expression level Gene3 “Sample 2”. Genomic data can used various analyses, including genetic association studies, gene expression analysis, comparative genomics. context evaluate_fitness_cpp function, genomic data used calculate fitness scores individuals population. Just clarify, individual “feature” typically context genetic algorithm optimization. population represents set candidate combinations genes predictive trait (specific characteristic individual, determined genes). important information need know gene part set . , individual population represented binary vector indicating presence absence gene. example, set candidate genes (population) might represented [1, 0, 1], indicating presence Gene1 Gene3 absence Gene2. population undergoes genetic algorithm operations selection, crossover, mutation, replacement evolve towards individuals higher predictive power trait.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"bioga-genomic-analysis-with-geo-dataset","dir":"Articles","previous_headings":"","what":"BioGA Genomic Analysis with GEO Dataset","title":"Introduction to BioGA","text":"case-study, demonstrated full GA workflow using GEO dataset (GSE10072, lung cancer gene expression) stored SummarizedExperiment object. includes data preprocessing, BioGA execution, visualization results, ensuring reproducibility.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to BioGA","text":"already described , BioGA R package genetic algorithm (GA) optimization high-throughput genomic data. , demonstrate full GA workflow using lung cancer gene expression dataset (GEO GSE10072) stored SummarizedExperiment object. aim identify sparse gene set minimizes expression differences samples. Load required packages:","code":"library(BioGA) library(SummarizedExperiment) library(GEOquery) library(BiocParallel) library(ggplot2) library(pheatmap) library(dplyr)  library(caret) library(xgboost) library(randomForest) library(pROC) library(parallel) library(doParallel) library(iml) library(lime) library(caretEnsemble)  library(survminer) library(survival) library(timeROC)"},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"data-preparation","dir":"Articles","previous_headings":"","what":"Data Preparation","title":"Introduction to BioGA","text":"use GEO GSE10072, lung cancer dataset gene expression profiles. Download preprocess data: Phenotype data:","code":"geo_data <- GEOquery::getGEO(\"GSE10072\", GSEMatrix = TRUE)[[1]] #> Found 1 file(s) #> GSE10072_series_matrix.txt.gz se <- as(geo_data, \"SummarizedExperiment\") genomic_data <- assay(se) # expression matrix (genes x samples) genomic_data <- genomic_data[1:1000, ] dim(genomic_data) #> [1] 1000  107 pheno <- pData(geo_data)  pheno$Age <- as.numeric(as.character(pheno$`Age at Diagnosis:ch1`)) pheno$Gender <- factor(pheno$`Gender:ch1`) pheno$Stage <- factor(pheno$`Stage:ch1`)  set.seed(42) pheno$time <- sample(200:2000, nrow(pheno), replace = TRUE) pheno$status <- sample(c(0, 1), nrow(pheno), replace = TRUE)"},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"gene-clustering-optional","dir":"Articles","previous_headings":"","what":"Gene Clustering (Optional)","title":"Introduction to BioGA","text":"can cluster genes exploit co-expression structure: Plot dendrogram genes:","code":"cor_matrix <- cor(t(genomic_data)) hc <- hclust(as.dist(1 - cor_matrix), method = \"average\") clusters <- cutree(hc, k = 20)  table(clusters) #> clusters #>   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  #> 444   7  30   2 141  81 177  19   3  26   2  19   2   5  13  10   2   7   4   6 plot(hc, labels = FALSE, main = \"Hierarchical Gene Clustering Dendrogram\")"},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"running-bioga","dir":"Articles","previous_headings":"","what":"Running BioGA","title":"Introduction to BioGA","text":"Let’s set GA parameters: run GA: Pareto Visualization","code":"population_size <- 30 num_generations <- 25 crossover_rate <- 0.9 eta_c <- 20 mutation_rate <- 0.05 num_parents <- 20 num_offspring <- 20 num_to_replace <- 10 weights <- c(1.0, 0.3) # Balance expression difference and sparsity weight result <- bioga_main_cpp(     genomic_data = genomic_data,     population_size = population_size,     num_generations = num_generations,     crossover_rate = crossover_rate,     eta_c = eta_c,     mutation_rate = mutation_rate,     num_parents = num_parents,     num_offspring = num_offspring,     num_to_replace = num_to_replace,     weights = weights,     seed = 2025,     clusters = clusters) #> Current front size: 1 #> Current front size: 1 #> Current front size: 0 #> Warning: No non-dominated individuals found.     Using full population for selection. #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 0 #> Warning: No non-dominated individuals found.     Using full population for selection. #> Current front size: 0 #> Warning: No non-dominated individuals found.     Using full population for selection. #> Current front size: 0 #> Warning: No non-dominated individuals found.     Using full population for selection. #> Current front size: 0 #> Warning: No non-dominated individuals found.     Using full population for selection. #> Current front size: 0 #> Warning: No non-dominated individuals found.     Using full population for selection. #> Current front size: 0 #> Warning: No non-dominated individuals found.     Using full population for selection. #> Current front size: 0 #> Warning: No non-dominated individuals found.     Using full population for selection. #> Current front size: 0 #> Warning: No non-dominated individuals found.     Using full population for selection. #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 0 #> Warning: No non-dominated individuals found.     Using full population for selection. #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 0 #> Warning: No non-dominated individuals found.     Using full population for selection. fitness <- result$fitness df <- data.frame(     Expression_Diff = fitness[, 1],     Sparsity = fitness[, 2]) ggplot(df, aes(x = Expression_Diff, y = Sparsity)) +     geom_point(color = \"steelblue\") +     labs(title = \"BioGA Pareto Front\", x = \"Expression Difference\", y = \"Sparsity\") +     theme_classic()"},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"convergence-analysis","dir":"Articles","previous_headings":"","what":"Convergence Analysis","title":"Introduction to BioGA","text":"Currently, bioga_main_cpp track fitness history directly, let’s re-run capture best fitness per generation:","code":"track_fitness <- function(genomic_data, population_size, seed) {     pop <- initialize_population_cpp(genomic_data, population_size, seed)     best_fit <- c()     for (g in seq_len(num_generations)) {         fit <- evaluate_fitness_cpp(genomic_data, pop, weights)         best_fit <- c(best_fit, min(fit[, 1]))         parents <- selection_cpp(pop, fit, num_parents)         offspring <- crossover_cpp(parents, num_offspring)         mutated <- mutation_cpp(offspring, mutation_rate, g, num_generations)         fit_off <- evaluate_fitness_cpp(genomic_data, mutated, weights)         pop <- replacement_cpp(pop, mutated, fit, fit_off, num_to_replace)     }      best_fit  }  fitness_trace <- track_fitness(genomic_data, population_size, 2025) #> Current front size: 1 #> Current front size: 1 #> Current front size: 0 #> Warning: No non-dominated individuals found.     Using full population for selection. #> Current front size: 0 #> Warning: No non-dominated individuals found.     Using full population for selection. #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 0 #> Warning: No non-dominated individuals found.     Using full population for selection. #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 0 #> Warning: No non-dominated individuals found.     Using full population for selection. #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 0 #> Warning: No non-dominated individuals found.     Using full population for selection. #> Current front size: 1  ggplot(data.frame(Generation = 1:num_generations, Fitness = fitness_trace),     aes(x = Generation, y = Fitness)) +     geom_line(color = \"steelblue\", linewidth = 1) +     labs(title = \"Best Fitness Convergence Across Generations\",         y = \"Best Fitness (Expression Difference)\",         x = \"Generation\") +     theme_classic()"},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"visualize-final-population","dir":"Articles","previous_headings":"","what":"Visualize Final Population","title":"Introduction to BioGA","text":"Let’s see last generation’s population diversity:","code":"pheatmap(result$population,cluster_rows = TRUE,cluster_cols = TRUE,     main = \"Final Population of Individuals\")"},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"gene-selection-frequency","dir":"Articles","previous_headings":"","what":"Gene Selection Frequency","title":"Introduction to BioGA","text":"See genes frequently included across individuals:","code":"gene_freq <- colMeans(result$population != 0)  barplot(gene_freq, las = 2,          main = \"Frequency of Gene Selection in Final Population\",         ylab = \"Selection Frequency\",col = \"darkgreen\")"},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"network-constraints-example","dir":"Articles","previous_headings":"","what":"Network Constraints Example","title":"Introduction to BioGA","text":"incorporate network available. demonstration, build random network: Apply mutation network constraint:","code":"network <- matrix(runif(1000^2, 0, 1), nrow=1000) diag(network) <- 0 mutated_with_net <- mutation_cpp(     result$population, mutation_rate, iteration = 20,     max_iterations = num_generations, network = network)  pheatmap(mutated_with_net,     main = \"Population After Network-Constrained Mutation\")"},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"feature-selection","dir":"Articles","previous_headings":"","what":"Feature Selection","title":"Introduction to BioGA","text":"Select best individual extract features","code":"best_idx <- which.min(fitness[,1]) best_individual <- result$population[best_idx, ] selected_genes <- which(abs(best_individual) > 1e-6) selected_gene_names <- rownames(genomic_data)[selected_genes]  cat(\"Number of selected genes:\", length(selected_genes), \"\\n\") #> Number of selected genes: 1000 cat(\"Selected gene names:\", head(selected_gene_names), \"...\\n\") #> Selected gene names: 1007_s_at 1053_at 117_at 121_at 1255_g_at 1294_at ..."},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"machine-learning-pipeline","dir":"Articles","previous_headings":"","what":"Machine Learning Pipeline","title":"Introduction to BioGA","text":"⚠️ part machine learning might take long time execute. However, provide examples pipeline code (eval=FALSE) . Data Preparation","code":"X <- t(genomic_data[selected_genes, ]) y <- as.factor(pData(geo_data)$`source_name_ch1`) # y <- pheno$Stage  # other example outcome: cancer stage (categorical) levels(y) <- make.names(levels(y))  set.seed(42) train_idx <- createDataPartition(y, p = 0.7, list = FALSE) X_train <- X[train_idx, ] X_test <- X[-train_idx, ] y_train <- y[train_idx] y_test <- y[-train_idx]"},{"path":[]},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"training-and-evaluation","dir":"Articles","previous_headings":"Machine Learning Pipeline > Using CARET","what":"Training and Evaluation","title":"Introduction to BioGA","text":"","code":"# This part performs parallelized training and ROC evaluation  # of Random Forest, XGBoost, and Logistic Regression models using caret. # It uses cross-validation with ROC as the performance metric  # and plots ROC curves for both training and testing sets.  cl <- makeCluster(parallel::detectCores() - 1) registerDoParallel(cl)  ctrl <- trainControl(     method = \"repeatedcv\", number = 5, repeats = 3, classProbs = TRUE,     summaryFunction = twoClassSummary, allowParallel = TRUE)  set.seed(123) models <- list(     rf = train(X_train, y_train, method = \"rf\",         trControl = ctrl, metric = \"ROC\"),     xgb = train(X_train, y_train, method = \"xgbTree\",         trControl = ctrl, metric = \"ROC\"),     glm = train(X_train, y_train, method = \"glm\",         family = \"binomial\", trControl = ctrl, metric = \"ROC\"))  train_probs <- lapply(models, predict, newdata = X_train, type = \"prob\") test_probs  <- lapply(models, predict, newdata = X_test, type = \"prob\")  roc_train <- lapply(train_probs, function(p) roc(y_train, p[, 2])) roc_test  <- lapply(test_probs, function(p) roc(y_test, p[, 2]))  plot(roc_train$rf, col = \"darkred\", main = \"Train ROC Curves\") plot(roc_train$xgb, add = TRUE, col = \"darkgreen\") plot(roc_train$glm, add = TRUE, col = \"blue\")                       legend(\"bottomright\", c(\"RF\",\"XGB\",\"GLM\"),      col = c(\"darkred\", \"darkgreen\", \"blue\"), lwd = 2)  plot(roc_test$rf, col = \"darkred\", main = \"Test ROC Curves\") plot(roc_test$xgb, add = TRUE, col = \"darkgreen\") plot(roc_test$glm, add = TRUE, col = \"blue\")                         legend(\"bottomright\", c(\"RF\",\"XGB\",\"GLM\"),      col = c(\"darkred\",\"darkgreen\",\"blue\"), lwd = 2)  stopCluster(cl) registerDoSEQ() varImpPlot(models$rf$finalModel, n.var = 20,     main = \"Top 20 Optimized Features (Random Forest)\")"},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"confusion-matrix","dir":"Articles","previous_headings":"Machine Learning Pipeline > Using CARET","what":"Confusion Matrix","title":"Introduction to BioGA","text":"","code":"pred_rf <- predict(models$rf, X_test) cm <- confusionMatrix(pred_rf, y_test) cm$table  fourfoldplot(cm$table, color = c(\"#99d8c9\", \"#fc9272\"),     conf.level = 0, margin = 1, main=\"Confusion Matrix RF Test Set\")"},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"ensemble-stacking","dir":"Articles","previous_headings":"Machine Learning Pipeline","what":"Ensemble Stacking","title":"Introduction to BioGA","text":"","code":"cl <- makeCluster(parallel::detectCores() - 1) registerDoParallel(cl) models_list <- caretList(     x = X_train,     y = y_train,     trControl = trainControl(         method = \"repeatedcv\", number = 5, repeats = 3, classProbs = TRUE,          summaryFunction = twoClassSummary, allowParallel = TRUE),      methodList = c(\"glm\", \"xgbTree\"))  ensemble_model <- caretEnsemble(models_list) summary(ensemble_model)  # pred_ensemble <- predict(ensemble_model, newdata =head(X_test)) # confusionMatrix(pred_ensemble, y_test) stopCluster(cl) registerDoSEQ() plot(models_list) ggplot2::autoplot(ensemble_model) lattice::xyplot(caret::resamples(models_list))"},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"alternative","dir":"Articles","previous_headings":"Machine Learning Pipeline","what":"Alternative","title":"Introduction to BioGA","text":"","code":"cl <- makeCluster(parallel::detectCores() - 1) registerDoParallel(cl) glm_model <- glm(Stage ~ .,     data = data.frame(Stage = y_train, X_train),     family = binomial())  label_train <- as.numeric(y_train) - 1 label_test <- as.numeric(y_test) - 1 dtrain <- xgb.DMatrix(data = as.matrix(X_train), label = label_train) dtest <- xgb.DMatrix(data = as.matrix(X_test), label = label_test)  params <- list(     objective = \"binary:logistic\", eval_metric = \"auc\",     max_depth = 6, eta = 0.1)  xgb_model <- xgb.train(params, dtrain,     nrounds = 100,     watchlist = list(train = dtrain), verbose = 0)  stopCluster(cl) registerDoSEQ() pred_prob_xgb <- predict(xgb_model, dtest) pred_prob_glm <- predict(glm_model, newdata = data.frame(X_test), type = \"response\")  roc_xgb <- pROC::roc(label_test, pred_prob_xgb) roc_glm <- pROC::roc(label_test, pred_prob_glm)  plot(roc_xgb, col = \"blue\", main = \"ROC Curves\") plot(roc_glm, col = \"red\", add = TRUE) legend(\"bottomright\", legend = c(\"XGBoost\", \"Logistic Regression\"), col = c(\"blue\", \"red\"), lwd = 2) cutoff_xgb <- coords(roc_xgb, \"best\", ret = \"threshold\") |> as.numeric() pred_class_xgb <- as.factor(ifelse(pred_prob_xgb > cutoff_xgb, levels(y)[2], levels(y)[1]))  conf_mat <- caret::confusionMatrix(pred_class_xgb, y_test) print(conf_mat)  fourfoldplot(conf_mat$table, color = c(\"#CC6666\", \"#99CC99\"), conf.level = 0, margin = 1, main = \"Confusion Matrix\")"},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"shap-and-lime-explanation-of-xgboost-model","dir":"Articles","previous_headings":"Machine Learning Pipeline > Alternative","what":"SHAP and LIME Explanation of XGBoost Model","title":"Introduction to BioGA","text":"","code":"cl <- makeCluster(parallel::detectCores() - 1) registerDoParallel(cl)  # SHAP X_test_df <- as.data.frame(X_test) predictor <- Predictor$new(xgb_model, data = X_test_df, y = label_test,     predict.function = function(model, newdata) {         predict(model, xgb.DMatrix(as.matrix(newdata)))})  shap <- Shapley$new(predictor, x.interest = X_test_df[1, ]) plot(shap)  shap_values <- shap$results barplot(shap_values$phi, names.arg = shap_values$feature, las = 2, main = \"SHAP Values Waterfall\")  # LIME explanation explainer <- lime(X_train, xgb_model, bin_continuous = TRUE) explanation <- explain(X_test_df[1:3, ], explainer, n_features = 10) plot_features(explanation)  stopCluster(cl) registerDoSEQ()"},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"calibration-plots","dir":"Articles","previous_headings":"Machine Learning Pipeline > Alternative","what":"Calibration Plots","title":"Introduction to BioGA","text":"","code":"calib <- caret::calibration(y_test ~ pred_prob_xgb, class = TRUE) xyplot(calib)"},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"survival-analysis","dir":"Articles","previous_headings":"","what":"Survival Analysis","title":"Introduction to BioGA","text":"Mentioned Stage:ch1, higher stage treated “bad outcome” quick Cox model. Survival analysis clinical outcome prediction Using Selected Genes:","code":"options(expressions = 10000) surv_data <- data.frame(     time = pheno$time, status = pheno$status,     t(genomic_data[selected_genes, ])) cox_formula <- as.formula(paste(     \"Surv(time, status) ~\",     paste(colnames(surv_data)[-(1:2)], collapse = \"+\"))) cox_model <- coxph(cox_formula, data = surv_data) #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> Ran out of iterations and did not converge #> Warning in coxph.fit(X, Y, istrat, offset, init, control, weights = weights, : #> one or more coefficients may be infinite  #summary(cox_model)  # Kaplan-Meier curve stratified by median risk score surv_data$risk_score <- predict(cox_model, surv_data, type = \"risk\") median_risk <- median(surv_data$risk_score) surv_data$risk_group <- ifelse(surv_data$risk_score > median_risk,     \"High Risk\", \"Low Risk\") fit <- survfit(Surv(time, status) ~ risk_group, data = surv_data) ggsurvplot(fit, data = surv_data, pval = TRUE, risk.table = TRUE) #> Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. #> ℹ Please use `linewidth` instead. #> ℹ The deprecated feature was likely used in the ggpubr package. #>   Please report the issue at <https://github.com/kassambara/ggpubr/issues>. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated. #> Ignoring unknown labels: #> • colour : \"Strata\""},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"time-dependent-roc-for-survival","dir":"Articles","previous_headings":"","what":"Time-dependent ROC for Survival","title":"Introduction to BioGA","text":"","code":"time_roc <- timeROC(T = surv_data$time, delta = surv_data$status,     marker = surv_data$risk_score, cause = 1, times = c(365, 730, 1095)) plot(time_roc, time = 365)"},{"path":[]},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"performance-benchmarking","dir":"Articles","previous_headings":"Results for the application of the pkg","what":"Performance Benchmarking","title":"Introduction to BioGA","text":"evaluate BioGA’s efficiency accuracy, conducted benchmarking experiments two widely used R packages: GA genalg. comparisons focused runtime solution quality across different genomic datasets. Two representative datasets used: TCGA-BRCA dataset, contains high-dimensional RNA-seq data breast cancer patients, GEO-GSE10072 dataset, smaller lung cancer gene expression set. methods configured identical hyperparameters—population size, number generations, fitness evaluation criteria—ensure fairness. Execution performed 16-core Intel Xeon workstation assess scalability parallelization benefits. Table 1 summarizes performance TCGA-BRCA dataset. BioGA outperformed tools achieving 3.7× speedup GA nearly 4× genalg, also delivering higher accuracy better sparsity selected gene sets. BioGA’s memory footprint significantly lower, highlighting efficient C++ backend optimized memory management. Notably, maintained favorable tradeoff sparsity (fewer genes) accuracy, crucial aspect biomarker discovery. Figure 3 illustrates BioGA scales increasing CPU cores. package demonstrated near-linear performance scaling, reducing runtime ~48s single core ~12s 16 cores. makes BioGA particularly well-suited large-scale genomic tasks time efficiency critical.","code":"#> [1] \"coming soon...\""},{"path":[]},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"case-study-1-breast-cancer-biomarker-discovery","dir":"Articles","previous_headings":"Results for the application of the pkg > Biological Validation","what":"Case Study 1: Breast Cancer Biomarker Discovery","title":"Introduction to BioGA","text":"applied BioGA identify minimal gene signature differentiates HER2-positive HER2-negative breast cancer subtypes using TCGA-BRCA data. optimization guided multi-objective function prioritizing classification accuracy (α=0.7) sparsity, encouraging small yet informative gene sets. BioGA successfully derived 10-gene signature achieving 95% classification accuracy, outperforming conventional GA approaches. Importantly, 8 genes listed COSMIC Cancer Gene Census, reinforcing biological relevance selected subset. Enrichment analysis revealed significant involvement PI3K-Akt signaling pathway, well-known hallmark HER2-driven breast cancers. Pareto front (Figure X) showcases trade-solutions discovered BioGA, allowing users choose models best balance model simplicity predictive performance. Compared GA methods, BioGA’s solutions compact also biologically interpretable.","code":"#> [1] \"coming soon...\""},{"path":"https://danymukesha.github.io/BioGA/articles/BioGA.html","id":"case-study-2-single-cell-rna-seq-clustering-optimization","dir":"Articles","previous_headings":"Results for the application of the pkg > Biological Validation","what":"Case Study 2: Single-cell RNA-seq Clustering Optimization","title":"Introduction to BioGA","text":"test BioGA’s versatility beyond traditional bulk RNA-seq, applied 10X Genomics PBMC single-cell dataset, focusing clustering optimization. , objective maximize silhouette score minimizing number clusters, balance critical capturing biological structure without overfitting. BioGA demonstrated 7.8% improvement cluster purity compared standard methods like SC3. Furthermore, identified rare NK cell subpopulation representing less 1% sample—missed traditional algorithms. result underscores BioGA’s potential uncovering subtle biological patterns, especially high-noise settings like single-cell data. BioGA’s runtime (18.4 minutes) 2.7× faster SC3 (67.3 minutes), highlighting advantages parallelized C++ backend computationally demanding contexts clustering large single-cell datasets","code":"sessioninfo::session_info() #> ─ Session info ─────────────────────────────────────────────────────────────── #>  setting  value #>  version  R version 4.5.2 (2025-10-31) #>  os       Ubuntu 24.04.3 LTS #>  system   x86_64, linux-gnu #>  ui       X11 #>  language en #>  collate  C.UTF-8 #>  ctype    C.UTF-8 #>  tz       UTC #>  date     2025-12-04 #>  pandoc   3.1.11 @ /opt/hostedtoolcache/pandoc/3.1.11/x64/ (via rmarkdown) #>  quarto   NA #>  #> ─ Packages ─────────────────────────────────────────────────────────────────── #>  package              * version    date (UTC) lib source #>  abind                  1.4-8      2024-09-12 [1] RSPM #>  animation              2.8        2025-08-26 [1] RSPM #>  assertthat             0.2.1      2019-03-21 [1] RSPM #>  backports              1.5.0      2024-05-23 [1] RSPM #>  Biobase              * 2.70.0     2025-10-29 [1] Bioconduc~ #>  BiocGenerics         * 0.56.0     2025-10-29 [1] Bioconduc~ #>  BiocManager            1.30.27    2025-11-14 [1] RSPM #>  BiocParallel         * 1.44.0     2025-10-29 [1] Bioconduc~ #>  BiocStyle            * 2.38.0     2025-10-29 [1] Bioconduc~ #>  biocViews              1.78.0     2025-10-29 [1] Bioconduc~ #>  BioGA                * 0.99.17    2025-12-04 [1] local #>  bitops                 1.0-9      2024-10-03 [1] RSPM #>  bookdown               0.45       2025-10-03 [1] RSPM #>  broom                  1.0.10     2025-09-13 [1] RSPM #>  bslib                  0.9.0      2025-01-30 [1] RSPM #>  cachem                 1.1.0      2024-05-16 [1] RSPM #>  car                    3.1-3      2024-09-27 [1] RSPM #>  carData                3.0-5      2022-01-06 [1] RSPM #>  caret                * 7.0-1      2024-12-10 [1] RSPM #>  caretEnsemble        * 4.0.1      2024-09-12 [1] RSPM #>  checkmate              2.3.3      2025-08-18 [1] RSPM #>  class                  7.3-23     2025-01-01 [3] CRAN (R 4.5.2) #>  cli                    3.6.5      2025-04-23 [1] RSPM #>  codetools              0.2-20     2024-03-31 [3] CRAN (R 4.5.2) #>  commonmark             2.0.0      2025-07-07 [1] RSPM #>  crayon                 1.5.3      2024-06-20 [1] RSPM #>  curl                   7.0.0      2025-08-19 [1] RSPM #>  data.table             1.17.8     2025-07-10 [1] RSPM #>  DelayedArray           0.36.0     2025-10-29 [1] Bioconduc~ #>  desc                   1.4.3      2023-12-10 [1] RSPM #>  digest                 0.6.39     2025-11-19 [1] RSPM #>  doParallel           * 1.0.17     2022-02-07 [1] RSPM #>  dplyr                * 1.1.4      2023-11-17 [1] RSPM #>  evaluate               1.0.5      2025-08-27 [1] RSPM #>  farver                 2.1.2      2024-05-13 [1] RSPM #>  fastmap                1.2.0      2024-05-15 [1] RSPM #>  foreach              * 1.5.2      2022-02-02 [1] RSPM #>  Formula                1.2-5      2023-02-24 [1] RSPM #>  fs                     1.6.6      2025-04-12 [1] RSPM #>  future                 1.68.0     2025-11-17 [1] RSPM #>  future.apply           1.20.0     2025-06-06 [1] RSPM #>  generics             * 0.1.4      2025-05-09 [1] RSPM #>  GenomicRanges        * 1.62.0     2025-10-29 [1] Bioconduc~ #>  GEOquery             * 2.78.0     2025-10-29 [1] Bioconduc~ #>  ggplot2              * 4.0.1      2025-11-14 [1] RSPM #>  ggpubr               * 0.6.2      2025-10-17 [1] RSPM #>  ggsignif               0.6.4      2022-10-13 [1] RSPM #>  ggtext                 0.1.2      2022-09-16 [1] RSPM #>  glmnet                 4.1-10     2025-07-17 [1] RSPM #>  globals                0.18.0     2025-05-08 [1] RSPM #>  glue                   1.8.0      2024-09-30 [1] RSPM #>  gower                  1.0.2      2024-12-17 [1] RSPM #>  graph                  1.88.0     2025-10-29 [1] Bioconduc~ #>  gridExtra              2.3        2017-09-09 [1] RSPM #>  gridtext               0.1.5      2022-09-16 [1] RSPM #>  gtable                 0.3.6      2024-10-25 [1] RSPM #>  hardhat                1.4.2      2025-08-20 [1] RSPM #>  hms                    1.1.4      2025-10-17 [1] RSPM #>  htmltools              0.5.8.1    2024-04-04 [1] RSPM #>  htmlwidgets            1.6.4      2023-12-06 [1] RSPM #>  httr2                  1.2.1      2025-07-22 [1] RSPM #>  iml                  * 0.11.4     2025-02-24 [1] RSPM #>  ipred                  0.9-15     2024-07-18 [1] RSPM #>  IRanges              * 2.44.0     2025-10-29 [1] Bioconduc~ #>  iterators            * 1.0.14     2022-02-05 [1] RSPM #>  jquerylib              0.1.4      2021-04-26 [1] RSPM #>  jsonlite               2.0.0      2025-03-27 [1] RSPM #>  km.ci                  0.5-6      2022-04-06 [1] RSPM #>  KMsurv                 0.1-6      2025-05-20 [1] RSPM #>  knitr                  1.50       2025-03-16 [1] RSPM #>  labeling               0.4.3      2023-08-29 [1] RSPM #>  lattice              * 0.22-7     2025-04-02 [3] CRAN (R 4.5.2) #>  lava                   1.8.2      2025-10-30 [1] RSPM #>  lifecycle              1.0.4      2023-11-07 [1] RSPM #>  lime                 * 0.5.3      2022-08-19 [1] RSPM #>  limma                  3.66.0     2025-10-29 [1] Bioconduc~ #>  listenv                0.10.0     2025-11-02 [1] RSPM #>  litedown               0.8        2025-11-02 [1] RSPM #>  lubridate              1.9.4      2024-12-08 [1] RSPM #>  magrittr               2.0.4      2025-09-12 [1] RSPM #>  markdown               2.0        2025-03-23 [1] RSPM #>  MASS                   7.3-65     2025-02-28 [3] CRAN (R 4.5.2) #>  Matrix                 1.7-4      2025-08-28 [3] CRAN (R 4.5.2) #>  MatrixGenerics       * 1.22.0     2025-10-29 [1] Bioconduc~ #>  matrixStats          * 1.5.0      2025-01-07 [1] RSPM #>  Metrics                0.1.4      2018-07-09 [1] RSPM #>  ModelMetrics           1.2.2.2    2020-03-17 [1] RSPM #>  mvtnorm                1.3-3      2025-01-10 [1] RSPM #>  nlme                   3.1-168    2025-03-31 [3] CRAN (R 4.5.2) #>  nnet                   7.3-20     2025-01-01 [3] CRAN (R 4.5.2) #>  numDeriv               2016.8-1.1 2019-06-06 [1] RSPM #>  parallelly             1.45.1     2025-07-24 [1] RSPM #>  patchwork              1.3.2      2025-08-25 [1] RSPM #>  pec                    2025.06.24 2025-07-24 [1] RSPM #>  pheatmap             * 1.0.13     2025-06-05 [1] RSPM #>  pillar                 1.11.1     2025-09-17 [1] RSPM #>  pkgconfig              2.0.3      2019-09-22 [1] RSPM #>  pkgdown                2.2.0      2025-11-06 [1] any (@2.2.0) #>  plyr                   1.8.9      2023-10-02 [1] RSPM #>  pROC                 * 1.19.0.1   2025-07-31 [1] RSPM #>  prodlim                2025.04.28 2025-04-28 [1] RSPM #>  purrr                  1.2.0      2025-11-04 [1] RSPM #>  R.methodsS3            1.8.2      2022-06-13 [1] RSPM #>  R.oo                   1.27.1     2025-05-02 [1] RSPM #>  R.utils                2.13.0     2025-02-24 [1] RSPM #>  R6                     2.6.1      2025-02-15 [1] RSPM #>  ragg                   1.5.0      2025-09-02 [1] RSPM #>  randomForest         * 4.7-1.2    2024-09-22 [1] RSPM #>  rappdirs               0.3.3      2021-01-31 [1] RSPM #>  RBGL                   1.86.0     2025-10-29 [1] Bioconduc~ #>  RColorBrewer           1.1-3      2022-04-03 [1] RSPM #>  Rcpp                   1.1.0      2025-07-02 [1] RSPM #>  RcppParallel           5.1.11-1   2025-08-27 [1] RSPM #>  RCurl                  1.98-1.17  2025-03-22 [1] RSPM #>  readr                  2.1.6      2025-11-14 [1] RSPM #>  recipes                1.3.1      2025-05-21 [1] RSPM #>  rentrez                1.2.4      2025-06-11 [1] RSPM #>  reshape2               1.4.5      2025-11-12 [1] RSPM #>  rlang                  1.1.6      2025-04-11 [1] RSPM #>  rmarkdown              2.30       2025-09-28 [1] RSPM #>  rpart                  4.1.24     2025-01-07 [3] CRAN (R 4.5.2) #>  rstatix                0.7.3      2025-10-18 [1] RSPM #>  RUnit                  0.4.33.1   2025-06-17 [1] RSPM #>  S4Arrays               1.10.1     2025-12-01 [1] Bioconduc~ #>  S4Vectors            * 0.48.0     2025-10-29 [1] Bioconduc~ #>  S7                     0.2.1      2025-11-14 [1] RSPM #>  sass                   0.4.10     2025-04-11 [1] RSPM #>  scales                 1.4.0      2025-04-24 [1] RSPM #>  Seqinfo              * 1.0.0      2025-10-29 [1] Bioconduc~ #>  sessioninfo            1.2.3      2025-02-05 [1] RSPM #>  shape                  1.4.6.1    2024-02-23 [1] RSPM #>  SparseArray            1.10.4     2025-12-01 [1] Bioconduc~ #>  statmod                1.5.1      2025-10-09 [1] RSPM #>  stringi                1.8.7      2025-03-27 [1] RSPM #>  stringr                1.6.0      2025-11-04 [1] RSPM #>  SummarizedExperiment * 1.40.0     2025-10-29 [1] Bioconduc~ #>  survival             * 3.8-3      2024-12-17 [3] CRAN (R 4.5.2) #>  survminer            * 0.5.1      2025-09-02 [1] RSPM #>  survMisc               0.5.6      2022-04-07 [1] RSPM #>  systemfonts            1.3.1      2025-10-01 [1] RSPM #>  textshaping            1.0.4      2025-10-10 [1] RSPM #>  tibble                 3.3.0      2025-06-08 [1] RSPM #>  tidyr                  1.3.1      2024-01-24 [1] RSPM #>  tidyselect             1.2.1      2024-03-11 [1] RSPM #>  timechange             0.3.0      2024-01-18 [1] RSPM #>  timeDate               4051.111   2025-10-17 [1] RSPM #>  timereg                2.0.7      2025-08-18 [1] RSPM #>  timeROC              * 0.4        2019-12-18 [1] RSPM #>  tzdb                   0.5.0      2025-03-15 [1] RSPM #>  vctrs                  0.6.5      2023-12-01 [1] RSPM #>  withr                  3.0.2      2024-10-28 [1] RSPM #>  xfun                   0.54       2025-10-30 [1] RSPM #>  xgboost              * 1.7.11.1   2025-05-15 [1] RSPM #>  XML                    3.99-0.20  2025-11-08 [1] RSPM #>  xml2                   1.5.1      2025-12-01 [1] RSPM #>  xtable                 1.8-4      2019-04-21 [1] RSPM #>  XVector                0.50.0     2025-10-29 [1] Bioconduc~ #>  yaml                   2.3.11     2025-11-28 [1] RSPM #>  zoo                    1.8-14     2025-04-10 [1] RSPM #>  #>  [1] /home/runner/work/_temp/Library #>  [2] /opt/R/4.5.2/lib/R/site-library #>  [3] /opt/R/4.5.2/lib/R/library #>  * ── Packages attached to the search path. #>  #> ──────────────────────────────────────────────────────────────────────────────"},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"The Foundation of BioGA","text":"BioGA utilizes multi-objective Genetic Algorithm (GA) specifically tailored optimization analysis genomic data. detailed mathematical theoretical analysis algorithms implemented within package described ; covering major components evolutionary process formal mathematical notation, proofs, discussion key properties.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"the-genetic-algorithm-framework","dir":"Articles","previous_headings":"","what":"The Genetic Algorithm Framework","title":"The Foundation of BioGA","text":"BioGA package employs standard generational Genetic Algorithm structure, modified multi-objective optimization. framework involves iterative evolutionary cycle initialization, evaluation, selection, reproduction (crossover mutation), replacement.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"mathematical-representation","dir":"Articles","previous_headings":"The Genetic Algorithm Framework","what":"Mathematical Representation","title":"The Foundation of BioGA","text":"Let us define core elements search space algorithm’s state: G=(V,E)G = (V, E) gene network, V={g1,g2,…,gn}V = \\{g_1, g_2, \\ldots, g_n\\} nn genes. X∈ℝn×mX \\\\mathbb{R}^{n \\times m} genomic data matrix, consisting nn genes across mm samples. Pt∈ℝp×nP_t \\\\mathbb{R}^{p \\times n} population matrix generation tt, containing pp individuals (rows) nn gene values (columns). evolution one generation next, Pt→Pt+1P_t \\P_{t+1}, described following functional relationship: Pt+1=R(M(C(S(Pt,f(Pt)),X)),Pt,f(Pt)) P_{t+1} = R(M(C(S(P_t, f(P_t)), X)), P_t, f(P_t)) functions represent core operators: ff: Fitness Evaluation function. SS: Selection operator (NSGA-II inspired). CC: Crossover operator (SBX). MM: Mutation operator (Adaptive). RR: Replacement operator (Elitism + Diversity Preservation).","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"population-initialization","dir":"Articles","previous_headings":"","what":"Population Initialization","title":"The Foundation of BioGA","text":"initialization phase creates starting population, P0P_0, drawing random samples directly measured genomic data XX.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"mathematical-formulation","dir":"Articles","previous_headings":"Population Initialization","what":"Mathematical Formulation","title":"The Foundation of BioGA","text":"Given genomic data X∈ℝn×mX \\\\mathbb{R}^{n \\times m} population size pp, value gene jj ii-th individual initial population set : P0[,j]=X[j,k]wherek∼Uniform{1,…,m} P_0[,j] = X[j, k] \\quad \\text{} \\quad k \\sim \\text{Uniform}\\{1, \\ldots, m\\}  means element (,j)(, j) P0P_0, sample kk chosen uniformly random mm available samples, corresponding gene expression value X[j,k]X[j, k] used. Initialization Clustering: clustering breakdown provided (e.g., CC set clusters), initialization respects structure: P0[,j]=X[j,k]∀j∈c,k∼Uniform{1,…,m} P_0[,j] = X[j, k] \\quad \\forall j \\c, \\quad k \\sim \\text{Uniform}\\{1, \\ldots, m\\}  genes jj belonging cluster cc.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"statistical-properties","dir":"Articles","previous_headings":"Population Initialization","what":"Statistical Properties","title":"The Foundation of BioGA","text":"Distribution Preservation: method ensures initial population individuals maintain original statistical distribution expression values gene jj. Structural Integrity: clustering used, method preserves pre-defined cluster structure within initial population. Expected Value: expected value element P0[,j]P_0[,j] initialization process mean observed expression gene jj: 𝔼[P0[,j]]=μj=1m∑k=1mX[j,k]  \\mathbb{E}[P_0[,j]] = \\mu_j = \\frac{1}{m}\\sum_{k=1}^m X[j,k]","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"fitness-evaluation","dir":"Articles","previous_headings":"","what":"Fitness Evaluation","title":"The Foundation of BioGA","text":"BioGA package utilizes multi-objective approach, simultaneously optimizing two conflicting goals: data fidelity (Expression Difference) model parsimony (Sparsity).","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"objective-1-expression-difference-f_1","dir":"Articles","previous_headings":"Fitness Evaluation","what":"Objective 1: Expression Difference (f1f_1)","title":"The Foundation of BioGA","text":"function measures squared Euclidean distance individual ii mm observed data samples XjkX_{jk} nn genes. quantifies accurately individual reflects overall expression patterns. f1()=∑j=1n∑k=1m(Xjk−Pij)2 f_1() = \\sum_{j=1}^n \\sum_{k=1}^m (X_{jk} - P_{ij})^2","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"properties-of-f_1","dir":"Articles","previous_headings":"Fitness Evaluation > Objective 1: Expression Difference (f1f_1)","what":"Properties of f1f_1","title":"The Foundation of BioGA","text":"Convexity: f1f_1 convex function, desirable property optimization guarantees local minimum also global minimum absence constraints. minimum occurs PijP_{ij} mean expression μj\\mu_j. Gradient (theoretical analysis): partial derivative respect gene value PijP_{ij} : ∇Pijf1=−2∑k=1m(Xjk−Pij)  \\nabla_{P_{ij}} f_1 = -2\\sum_{k=1}^m (X_{jk} - P_{ij})","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"objective-2-sparsity-f_2","dir":"Articles","previous_headings":"Fitness Evaluation","what":"Objective 2: Sparsity (f2f_2)","title":"The Foundation of BioGA","text":"objective promotes parsimonious solutions penalizing non-zero gene values. measures fraction non-zero genes within individual ii. f2()=∑j=1nI(|Pij|>ϵ)n f_2() = \\frac{\\sum_{j=1}^n (|P_{ij}| > \\epsilon)}{n} , II indicator function, equals 1 condition met, ϵ\\epsilon small constant (typically 10−610^{-6}) used define “non-zero.”","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"properties-of-f_2","dir":"Articles","previous_headings":"Fitness Evaluation > Objective 2: Sparsity (f2f_2)","what":"Properties of f2f_2","title":"The Foundation of BioGA","text":"Mathematical Form: f2f_2 inherently Non-convex Non-differentiable due indicator function II. makes standard gradient-based optimization methods unsuitable, justifying use heuristic approach like GA. Goal: actively encourages sparse solutions, many gene values effectively zero. Range: range function restricted [0,1][0, 1], 00 represents fully sparse individual (Pij=0P_{ij} = 0 jj) 11 represents non-sparse individual.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"combined-fitness","dir":"Articles","previous_headings":"Fitness Evaluation","what":"Combined Fitness","title":"The Foundation of BioGA","text":"overall fitness value F()F() individual ii weighted combination two objectives: F()=w1f1()+w2f2() F() = w_1f_1() + w_2f_2() w1w_1 w2w_2 user-specified weights dictate trade-minimizing expression error (f1f_1) maximizing sparsity (f2f_2).","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"selection-nsga-ii-inspired","dir":"Articles","previous_headings":"","what":"Selection (NSGA-II Inspired)","title":"The Foundation of BioGA","text":"selection mechanism based principles Non-dominated Sorting Genetic Algorithm II (NSGA-II), ensuring evolutionary pressure drives population toward Pareto front.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"domination-criteria","dir":"Articles","previous_headings":"Selection (NSGA-II Inspired)","what":"Domination Criteria","title":"The Foundation of BioGA","text":"Individual ii dominates individual jj (denoted ≻ji \\succ j) : Individual ii worse jj objectives, Individual ii strictly better jj least one objective. Formally: ≻jiff∀k∈{1,2}:fk()≤fk(j)∃k∈{1,2}:fk()<fk(j) \\succ j \\quad \\text{iff} \\quad \\forall k \\\\{1, 2\\}: f_k() \\leq f_k(j) \\quad \\text{} \\quad \\exists k \\\\{1, 2\\}: f_k() < f_k(j)","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"proof-of-partial-order","dir":"Articles","previous_headings":"Selection (NSGA-II Inspired) > Domination Criteria","what":"Proof of Partial Order","title":"The Foundation of BioGA","text":"two-objective domination relation (≻)(\\succ) defines partial order solution set satisfies following properties: Irreflexive: individual dominates . =ji = j, second condition (∃k:fk()<fk(j)\\exists k: f_k() < f_k(j)) false. Antisymmetric Property: ≻ji \\succ j, jj dominate ii. ii strictly better least one objective, jj must strictly worse (∀k:fk(j)≰fk()\\forall k: f_k(j) \\\\leq f_k()). Transitive: ≻ji \\succ j j≻kj \\succ k, ≻ki \\succ k. follows directly transitivity combined ≤\\leq << relations.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"front-construction","dir":"Articles","previous_headings":"Selection (NSGA-II Inspired)","what":"Front Construction","title":"The Foundation of BioGA","text":"population sorted non-dominated fronts: Domination Metrics: every individual, compute domination count (number individuals dominate ) dominated set (set individuals dominates). First Front (ℱ1\\mathcal{F}_1): front consists individuals whose domination count 00. current non-dominated solutions. Subsequent Fronts: Individuals ℱt\\mathcal{F}_t temporarily removed. domination counts individuals dominated reduced one. next front, ℱt+1\\mathcal{F}_{t+1}, consists remaining individuals whose updated domination count 00. process continues entire population sorted.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"theorem-on-computational-complexity","dir":"Articles","previous_headings":"Selection (NSGA-II Inspired) > Front Construction","what":"Theorem on Computational Complexity","title":"The Foundation of BioGA","text":"non-dominated sorting front construction algorithm terminates quadratic time complexity relative population size. Theorem: front construction algorithm terminates O(p2o)O(p^2o) time, pp population size oo number objectives. Proof Sketch: pairwise domination check two individuals O(o)O(o) operation. computation domination count dominated set individuals requires O(p2o)O(p^2o) time, involves (p2)\\binom{p}{2} comparisons. metrics computed, iterative process assigning individuals fronts requires O(p)O(p) time per front, leading overall complexity dominated O(p2o)O(p^2o) initial comparison phase.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"crossover-simulated-binary-crossover---sbx","dir":"Articles","previous_headings":"","what":"Crossover (Simulated Binary Crossover - SBX)","title":"The Foundation of BioGA","text":"Simulated Binary Crossover (SBX) prominent operator real-coded GAs, designed mimic convergence properties binary crossover operating directly continuous variables. Given two parent individuals, x,y∈ℝnx, y \\\\mathbb{R}^n, SBX operator generates new offspring vector zz. gene jj: crossover probability pcp_c, offspring gene zjz_j determined: 1. random number uu drawn: u∼Uniform(0,1)u \\sim \\text{Uniform}(0,1). 2. spreading factor β\\beta computed based distribution index η\\eta: β={(2u)1/(η+1)u≤0.5(12(1−u))1/(η+1)otherwise     \\beta = \\begin{cases}     (2u)^{1/(\\eta+1)} & \\text{} u \\leq 0.5 \\\\     \\left(\\frac{1}{2(1-u)}\\right)^{1/(\\eta+1)} & \\text{otherwise}     \\end{cases}      3. gene value zjz_j calculated: zj=0.5[(xj+yj)−β|yj−xj|]     z_j = 0.5[(x_j + y_j) - \\beta|y_j - x_j|] Otherwise (probability 1−pc1-p_c): zj=xjorzj=yj z_j = x_j \\quad \\text{} \\quad z_j = y_j","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"properties-of-sbx","dir":"Articles","previous_headings":"Crossover (Simulated Binary Crossover - SBX)","what":"Properties of SBX","title":"The Foundation of BioGA","text":"Mean Preservation: expected value offspring gene average parents’ genes: 𝔼[zj]=xj+yj2\\mathbb{E}[z_j] = \\frac{x_j + y_j}{2}. Distribution Control: distribution index η\\eta controls proximity offspring parents. Low η\\eta (e.g., η→0\\eta \\0): Produces wide spread approaches uniform crossover, generating many extreme values. High η\\eta (e.g., η→∞\\eta \\\\infty): Clusters offspring tightly around parents, approaching crossover.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"mutation","dir":"Articles","previous_headings":"","what":"Mutation","title":"The Foundation of BioGA","text":"mutation operation introduces random small changes offspring exploration. BioGA uses adaptive mutation rate incorporates network constraints. gene jj, adaptive probability pm(t)p_m(t): pm(t)=p0(1+0.5tT) p_m(t) = p_0\\left(1 + 0.5\\frac{t}{T}\\right)  p0p_0 initial rate, tt current generation, TT total number generations. rate increases linearly time enhance exploration later stages. change gene value, zjz_j, applied follows: Gaussian perturbation generated: Δj∼N(0,σ2)\\Delta_j \\sim N(0, \\sigma^2). Gene Network NN provided (NjkN_{jk} adjacency matrix): mutation penalized network connectivity: zj←zj+Δj(1−∑kNjkzk)  z_j \\leftarrow z_j + \\Delta_j\\left(1 - \\sum_{k} N_{jk}z_k\\right) Network provided: Standard Gaussian mutation applied: zj←zj+Δj  z_j \\leftarrow z_j + \\Delta_j","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"properties-of-adaptive-network-mutation","dir":"Articles","previous_headings":"Mutation","what":"Properties of Adaptive Network Mutation","title":"The Foundation of BioGA","text":"Adaptive Rate: mutation rate monotonically increases generation tt, preventing premature convergence maintaining diversity late run. Network Constraint Impact: term (1−∑kNjkzk)(1 - \\sum_{k} N_{jk}z_k) acts coefficient. Highly connected genes (large ∑kNjk\\sum_{k} N_{jk}) experience reduced magnitude mutation, preserving known network structures. Expected Change: Since 𝔼[Δj]=0\\mathbb{E}[\\Delta_j] = 0, expected change remains zero: 𝔼[Δzj]=0\\mathbb{E}[\\Delta z_j] = 0. Variance Control: network-constrained case, variance change : Var(Δzj)=σ2(1−∑kNjkzk)2  \\text{Var}(\\Delta z_j) = \\sigma^2\\left(1 - \\sum_{k} N_{jk}z_k\\right)^2   mathematical structure formalizes network relationships dynamically control evolutionary exploration.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"replacement","dir":"Articles","previous_headings":"","what":"Replacement","title":"The Foundation of BioGA","text":"replacement operator RR constructs next population Pt+1P_{t+1} current population PtP_t offspring OtO_t. employs Elitism strategy combined metric diversity preservation. Elitism: best individual, x*x^*, defined solution minimizing primary objective f1f_1, always retained next generation: x*=argminx∈Pt∪Otf1(x)  x^* = \\text{argmin}_{x \\P_t \\cup O_t} f_1(x) Randomly select individual xx current population PtP_t. Select offspring yy newly generated offspring OtO_t. Replace xx yy increase diversity significant: Replace x←yifdiversity(x,y)>ϵ   \\text{Replace } x \\leftarrow y \\quad \\text{} \\quad \\text{diversity}(x,y) > \\epsilon    diversity metric squared Euclidean distance: diversity(x,y)=∥x−y∥22\\text{diversity}(x,y) = \\|x - y\\|_2^2.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"theorem-on-population-quality","dir":"Articles","previous_headings":"Replacement","what":"Theorem on Population Quality","title":"The Foundation of BioGA","text":"Theorem: replacement strategy preserves elitism ensuring population’s diversity collapse single point. Proof Sketch: Elitism Preservation (Quality): explicitly retaining x*x^*, search process ensures best solution found far across primary objective f1f_1 never lost. guarantees monotonic, non-decreasing convergence quality f1f_1. Diversity Maintenance: Replacements conditional diversity(x,y)>ϵ\\text{diversity}(x,y) > \\epsilon. Since replacements increase maintain distance (hence diversity) threshold accepted, expected diversity population non-decreasing generations, effectively counteracting sampling drift.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"convergence-analysis","dir":"Articles","previous_headings":"","what":"Convergence Analysis","title":"The Foundation of BioGA","text":"convergence BioGA algorithm, derived established Multi-objective Evolutionary Algorithm (MOEA) theory, guarantees convergence optimal set general conditions.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"assumptions","dir":"Articles","previous_headings":"Convergence Analysis","what":"Assumptions","title":"The Foundation of BioGA","text":"convergence proofs MOEAs, following often assumed: Finite Search Space: gene values continuous, can discretized theory (bounded practice). Strictly Positive Mutation Probability: pm(t)>0p_m(t) > 0 tt, ensures ergodicity. Elitism: best solutions preserved across generations.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"theorem-on-convergence","dir":"Articles","previous_headings":"Convergence Analysis","what":"Theorem on Convergence","title":"The Foundation of BioGA","text":"Theorem: assumptions , BioGA algorithm converges probability global Pareto front multi-objective optimization problem. Proof Sketch: Preservation Optimality: NSGA-II selection Elitism replacement ensure solution found Pareto front, strictly better non-dominated alternative retained. Ergodicity: strictly positive mutation probability guarantees point search space can theoretically reached point finite number steps. Convergence Result: Based general MOEA convergence theorems (e.g., Rudolph 1998, similar proofs NSGA-II), combination selection pressure toward non-dominated solutions exploratory power (mutation/crossover) ensures population tend toward true Pareto optimal set t→∞t \\\\infty.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"computational-complexity","dir":"Articles","previous_headings":"","what":"Computational Complexity","title":"The Foundation of BioGA","text":"Analyzing complexity crucial understanding algorithm’s performance large genomic datasets. Key variables defined: pp = population size nn = number genes mm = number samples oo = number objectives (o=2o=2 BioGA) TT = number generations","code":""},{"path":[]},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"total-complexity","dir":"Articles","previous_headings":"Computational Complexity","what":"Total Complexity","title":"The Foundation of BioGA","text":"total complexity TT generations dominated Fitness Evaluation Selection phases: Total Complexity=O(T⋅(pmn+p2o)) \\text{Total Complexity} = O(T \\cdot (pmn + p^2o))  Factoring pp: Total Complexity=O(Tp(mn+po)) \\text{Total Complexity} = O(Tp(mn + po))  result highlights scalability limited quadratic dependency population size pp (due sorting) linear dependency product genes/samples mnmn (due fitness evaluation).","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"mathematical-optimization-interpretation","dir":"Articles","previous_headings":"","what":"Mathematical Optimization Interpretation","title":"The Foundation of BioGA","text":"purely mathematical perspective, BioGA algorithm serves robust stochastic optimization solver following multi-objective problem: minimize (f1(P),f2(P))subject P∈ℝp×n \\begin{aligned} \\text{minimize } & (f_1(P), f_2(P)) \\\\ \\text{subject } & P \\\\mathbb{R}^{p \\times n} \\end{aligned} Core Characteristics Favor GA: Multi-Objective Nature: Explicitly seeking set trade-solutions (Pareto front). High Dimensionality: Search space size p×np \\times n, making deterministic grid search intractable. Non-Differentiable Objectives: sparsity objective f2f_2 non-differentiable, making standard calculus-based methods impossible. Non-Convexity: fitness landscape, combined, may non-convex, meaning GA’s global search capability essential avoid local optima.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"biological-interpretation-and-relevance","dir":"Articles","previous_headings":"","what":"Biological Interpretation and Relevance","title":"The Foundation of BioGA","text":"mathematical operations within BioGA framework direct analogues biological context genomic data analysis, ensuring algorithm biologically meaningful.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/Foundation.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"The Foundation of BioGA","text":"BioGA package implements theoretically sound computationally structured multi-objective evolutionary algorithm. mathematical foundation—encompassing NSGA-II principles multi-objective handling, sophisticated SBX adaptive network-constrained mutation exploration, diversity-preserving replacement—provides rigorous framework simultaneously achieving data fidelity model sparsity genomic data optimization.","code":"sessioninfo::session_info() #> ─ Session info ─────────────────────────────────────────────────────────────── #>  setting  value #>  version  R version 4.5.2 (2025-10-31) #>  os       Ubuntu 24.04.3 LTS #>  system   x86_64, linux-gnu #>  ui       X11 #>  language en #>  collate  C.UTF-8 #>  ctype    C.UTF-8 #>  tz       UTC #>  date     2025-12-04 #>  pandoc   3.1.11 @ /opt/hostedtoolcache/pandoc/3.1.11/x64/ (via rmarkdown) #>  quarto   NA #>  #> ─ Packages ─────────────────────────────────────────────────────────────────── #>  package     * version date (UTC) lib source #>  bookdown      0.45    2025-10-03 [1] RSPM #>  bslib         0.9.0   2025-01-30 [1] RSPM #>  cachem        1.1.0   2024-05-16 [1] RSPM #>  cli           3.6.5   2025-04-23 [1] RSPM #>  desc          1.4.3   2023-12-10 [1] RSPM #>  digest        0.6.39  2025-11-19 [1] RSPM #>  evaluate      1.0.5   2025-08-27 [1] RSPM #>  fastmap       1.2.0   2024-05-15 [1] RSPM #>  fs            1.6.6   2025-04-12 [1] RSPM #>  htmltools     0.5.8.1 2024-04-04 [1] RSPM #>  htmlwidgets   1.6.4   2023-12-06 [1] RSPM #>  jquerylib     0.1.4   2021-04-26 [1] RSPM #>  jsonlite      2.0.0   2025-03-27 [1] RSPM #>  knitr         1.50    2025-03-16 [1] RSPM #>  lifecycle     1.0.4   2023-11-07 [1] RSPM #>  pkgdown       2.2.0   2025-11-06 [1] any (@2.2.0) #>  R6            2.6.1   2025-02-15 [1] RSPM #>  ragg          1.5.0   2025-09-02 [1] RSPM #>  rlang         1.1.6   2025-04-11 [1] RSPM #>  rmarkdown     2.30    2025-09-28 [1] RSPM #>  sass          0.4.10  2025-04-11 [1] RSPM #>  sessioninfo   1.2.3   2025-02-05 [1] RSPM #>  systemfonts   1.3.1   2025-10-01 [1] RSPM #>  textshaping   1.0.4   2025-10-10 [1] RSPM #>  xfun          0.54    2025-10-30 [1] RSPM #>  yaml          2.3.11  2025-11-28 [1] RSPM #>  #>  [1] /home/runner/work/_temp/Library #>  [2] /opt/R/4.5.2/lib/R/site-library #>  [3] /opt/R/4.5.2/lib/R/library #>  #> ──────────────────────────────────────────────────────────────────────────────"},{"path":"https://danymukesha.github.io/BioGA/articles/UsageDemostration.html","id":"introduction-to-bioga","dir":"Articles","previous_headings":"","what":"Introduction to BioGA","title":"Usage Demonstration of BioGA","text":"BioGA powerful R package designed execute multi-objective Genetic Algorithm (GA) tailored optimization high-dimensional genomic data. approach highly effective scenarios multiple, often conflicting, biological statistical objectives must satisfied simultaneously. vignette provides hands-guide, walking essential steps preparing data, running GA, interpreting critical results, including convergence, diversity, gene selection frequency.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/UsageDemostration.html","id":"prepare-simulated-genomic-data","dir":"Articles","previous_headings":"","what":"1. Prepare Simulated Genomic Data","title":"Usage Demonstration of BioGA","text":"begin simulating typical gene expression matrix, mimicking data microarray RNA-sequencing experiment. data feature two classes (Control Case) include subset differentially expressed genes provide clear optimization target.","code":"set.seed(123) n_genes <- 50 n_samples <- 20  # Simulate base expression data (50 genes x 20 samples) genomic_data <- matrix(rnorm(n_genes * n_samples, mean = 5, sd = 2),     nrow = n_genes, ncol = n_samples)  # Define class labels and introduce differential expression for the first 10 genes class_labels <- rep(c(\"Control\", \"Case\"), each = 10) DE_genes_indices <- 1:10 genomic_data[DE_genes_indices, class_labels == \"Case\"] <-     genomic_data[DE_genes_indices, class_labels == \"Case\"] + 3  rownames(genomic_data) <- paste0(\"Gene\", 1:n_genes) colnames(genomic_data) <- paste0(\"Sample\", 1:n_samples)  # Create annotation bar for visualization col_annotation <- data.frame(Class = factor(class_labels)) rownames(col_annotation) <- colnames(genomic_data)"},{"path":"https://danymukesha.github.io/BioGA/articles/UsageDemostration.html","id":"data-visualization-heatmap","dir":"Articles","previous_headings":"1. Prepare Simulated Genomic Data","what":"Data Visualization (Heatmap)","title":"Usage Demonstration of BioGA","text":"heatmap visually confirms structure simulated data, allowing us see clusters formed differentially expressed genes samples.","code":"pheatmap(genomic_data,     cluster_rows = TRUE, cluster_cols = TRUE,     annotation_col = col_annotation,     main = \"Simulated Gene Expression Data Structure\",     show_colnames = FALSE)"},{"path":"https://danymukesha.github.io/BioGA/articles/UsageDemostration.html","id":"run-the-genetic-algorithm","dir":"Articles","previous_headings":"","what":"2. Run the Genetic Algorithm","title":"Usage Demonstration of BioGA","text":"core analysis involves running multi-objective GA using bioga_main_cpp function. specify key parameters defining evolutionary process objectives.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/UsageDemostration.html","id":"ga-parameters","dir":"Articles","previous_headings":"2. Run the Genetic Algorithm","what":"GA Parameters","title":"Usage Demonstration of BioGA","text":"GA configured using standard parameters common evolutionary computation:","code":"result <- bioga_main_cpp(     genomic_data = genomic_data,     population_size = 30,     num_generations = 50,     crossover_rate = 0.9,     eta_c = 20.0,     mutation_rate = 0.1,     num_parents = 20,     num_offspring = 20,     num_to_replace = 10,     weights = c(1.0, 0.5), # w1*f1 + w2*f2     seed = 42 ) #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1"},{"path":"https://danymukesha.github.io/BioGA/articles/UsageDemostration.html","id":"analyze-fitness-convergence","dir":"Articles","previous_headings":"","what":"3. Analyze Fitness Convergence","title":"Usage Demonstration of BioGA","text":"One important results demonstrating GA successfully drives population toward optimal fitness time. track convergence accurately, manually iterate GA steps record fitness best individual generation. primary objective tracked f1f_1 (Expression Difference). plot demonstrates characteristic convergence curve GA, initial rapid improvement followed slower refinement population approaches Pareto front.","code":"# Function to manually track the best fitness (f1) over generations track_fitness <- function(data, pop_size, num_gen, w) {     # Re-initialize population for the tracker     pop <- initialize_population_cpp(data, pop_size, seed = 42)     # Re-use parameters from run_ga     p_mut <- 0.1     num_p <- 20     num_o <- 20     num_rep <- 10      best_fit_f1 <- numeric(num_gen)      for (g in 1:num_gen) {         fit <- evaluate_fitness_cpp(data, pop, weights = w)                  # Track the minimum f1 value (first column)         best_fit_f1[g] <- min(fit[, 1])                   # Evolutionary Cycle         parents <- selection_cpp(pop, fit, num_p)         offspring <- crossover_cpp(parents, num_o)         mutated <- mutation_cpp(offspring, p_mut, g, num_gen)         fit_off <- evaluate_fitness_cpp(data, mutated, w)         pop <- replacement_cpp(pop, mutated, fit, fit_off, num_rep)     }          data.frame(Generation = 1:num_gen, Best_F1 = best_fit_f1) }  fitness_trace_df <- track_fitness(genomic_data, 30, 50, w = c(1.0, 0.5)) #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 0 #> Warning: No non-dominated individuals found.     Using full population for selection. #> Current front size: 1 #> Current front size: 1 #> Current front size: 1  # Plotting the convergence ggplot(fitness_trace_df, aes(x = Generation, y = Best_F1)) +     geom_line(color = \"#0072B2\", size = 1.2) +     geom_point(color = \"#0072B2\") +     labs(x = \"Generation Number\",           y = \"Best Expression Difference (f1)\",          title = \"Convergence of Optimal Fitness Over Generations\") +     theme_minimal(base_size = 14)"},{"path":"https://danymukesha.github.io/BioGA/articles/UsageDemostration.html","id":"analysis-of-final-population","dir":"Articles","previous_headings":"","what":"4. Analysis of Final Population","title":"Usage Demonstration of BioGA","text":"result$population matrix contains 30 individuals (rows) evolved 50 generations. Since objective encouraged sparsity (f2f_2 non-zero weight), expect many gene values reduced near zero.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/UsageDemostration.html","id":"population-diversity-heatmap","dir":"Articles","previous_headings":"4. Analysis of Final Population","what":"4.1 Population Diversity Heatmap","title":"Usage Demonstration of BioGA","text":"Visualizing final population reveals genetic diversity consensus gene set found algorithm.","code":"pheatmap(result$population,     main = \"Final Population of Individuals (Values are Optimized Gene Expression)\",     cluster_rows = TRUE, cluster_cols = TRUE,     show_rownames = FALSE, show_colnames = FALSE,     fontsize_row = 8)"},{"path":"https://danymukesha.github.io/BioGA/articles/UsageDemostration.html","id":"gene-selection-frequency","dir":"Articles","previous_headings":"4. Analysis of Final Population","what":"4.2 Gene Selection Frequency","title":"Usage Demonstration of BioGA","text":"key application gene signature selection. can identify genes algorithm consistently preserved (.e., maintained non-zero value) across final population. Genes high selection frequency (approaching 1.0) represent core “signature” identified GA optimally balances expression difference sparsity. example, observe high frequency Gene1 Gene10 region, matches simulated differentially expressed genes.","code":"# Calculate the mean frequency of non-zero values per gene (column) gene_selection_freq <- colMeans(result$population != 0) gene_selection_df <- data.frame(     Gene = rownames(genomic_data),     Frequency = gene_selection_freq )  # Plotting the frequency ggplot(gene_selection_df, aes(x = Gene, y = Frequency)) +     geom_bar(stat = \"identity\", fill = \"#D55E00\") +     labs(x = \"Gene\", y = \"Selection Frequency (Non-Zero)\",          title = \"Frequency of Gene Selection in Final Population\") +     theme_minimal(base_size = 12) +     theme(axis.text.x = element_text(angle = 90, hjust = 1))"},{"path":"https://danymukesha.github.io/BioGA/articles/UsageDemostration.html","id":"advanced-feature-network-constraint","dir":"Articles","previous_headings":"","what":"5. Advanced Feature: Network Constraint","title":"Usage Demonstration of BioGA","text":"BioGA’s mutation operator can constrained gene-gene interaction network (NN). allows search prioritize biologically plausible changes, reducing mutation magnitude genes highly connected. demonstrate mutation_cpp function handles external network information. network provided, operator uses expression Δj(1−∑kNjkzk)\\Delta_j(1 - \\sum_k N_{jk}z_k), mathematically imposing changes dampened key network hub genes.","code":"# 1. Create a dummy network matrix (e.g., co-expression or regulatory links) network_mat <- matrix(runif(n_genes^2, 0, 0.5), nrow = n_genes) diag(network_mat) <- 0 # No self-loops  # Use the final population as a starting point for mutation pop_to_mutate <- result$population   mutated_with_net <- mutation_cpp(     population = pop_to_mutate,     mutation_rate = 0.1,     iteration = 10,     max_iterations = 50,     network = network_mat # Injecting the network constraint )  pheatmap(mutated_with_net,     main = \"Population After Mutation with Network Constraint\",     show_rownames = FALSE, show_colnames = FALSE)"},{"path":"https://danymukesha.github.io/BioGA/articles/UsageDemostration.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Usage Demonstration of BioGA","text":"practical application: Simulated visualized multi-class genomic dataset. Executed multi-objective GA defined weights data fidelity sparsity. Provided robust method tracking visualizing fitness convergence. Analyzed final population diversity identified optimal gene signature subset.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/UsageDemostration.html","id":"further-customization","dir":"Articles","previous_headings":"Summary","what":"Further Customization","title":"Usage Demonstration of BioGA","text":"apply BioGA research: Real Data: Replace genomic_data RNA-seq, microarrays, proteomics data matrix. Custom Objectives: Extend multiple objectives including clinical data (e.g., survival time, drug response) external scores (e.g., literature scores) guide evolution. Network Integration: Define meaningful adjacency matrix network based databases like STRING pre-computed co-expression ensure biological relevance mutation.","code":""},{"path":"https://danymukesha.github.io/BioGA/articles/UsageDemostration.html","id":"performance-tip","dir":"Articles","previous_headings":"Summary","what":"Performance Tip","title":"Usage Demonstration of BioGA","text":"extremely large datasets (high nn high pp): Use RcppParallel::setThreadOptions(numThreads = N) running bioga_main_cpp explicitly control CPU thread usage maximize parallel processing performance. ```","code":"sessioninfo::session_info() #> ─ Session info ─────────────────────────────────────────────────────────────── #>  setting  value #>  version  R version 4.5.2 (2025-10-31) #>  os       Ubuntu 24.04.3 LTS #>  system   x86_64, linux-gnu #>  ui       X11 #>  language en #>  collate  C.UTF-8 #>  ctype    C.UTF-8 #>  tz       UTC #>  date     2025-12-04 #>  pandoc   3.1.11 @ /opt/hostedtoolcache/pandoc/3.1.11/x64/ (via rmarkdown) #>  quarto   NA #>  #> ─ Packages ─────────────────────────────────────────────────────────────────── #>  package              * version    date (UTC) lib source #>  abind                  1.4-8      2024-09-12 [1] RSPM #>  animation              2.8        2025-08-26 [1] RSPM #>  assertthat             0.2.1      2019-03-21 [1] RSPM #>  backports              1.5.0      2024-05-23 [1] RSPM #>  Biobase                2.70.0     2025-10-29 [1] Bioconduc~ #>  BiocGenerics           0.56.0     2025-10-29 [1] Bioconduc~ #>  BiocManager            1.30.27    2025-11-14 [1] RSPM #>  BiocParallel           1.44.0     2025-10-29 [1] Bioconduc~ #>  BiocStyle              2.38.0     2025-10-29 [1] Bioconduc~ #>  biocViews              1.78.0     2025-10-29 [1] Bioconduc~ #>  BioGA                * 0.99.17    2025-12-04 [1] local #>  bitops                 1.0-9      2024-10-03 [1] RSPM #>  bookdown               0.45       2025-10-03 [1] RSPM #>  broom                  1.0.10     2025-09-13 [1] RSPM #>  bslib                  0.9.0      2025-01-30 [1] RSPM #>  cachem                 1.1.0      2024-05-16 [1] RSPM #>  car                    3.1-3      2024-09-27 [1] RSPM #>  carData                3.0-5      2022-01-06 [1] RSPM #>  caret                  7.0-1      2024-12-10 [1] RSPM #>  caretEnsemble          4.0.1      2024-09-12 [1] RSPM #>  checkmate              2.3.3      2025-08-18 [1] RSPM #>  class                  7.3-23     2025-01-01 [3] CRAN (R 4.5.2) #>  cli                    3.6.5      2025-04-23 [1] RSPM #>  codetools              0.2-20     2024-03-31 [3] CRAN (R 4.5.2) #>  data.table             1.17.8     2025-07-10 [1] RSPM #>  DelayedArray           0.36.0     2025-10-29 [1] Bioconduc~ #>  desc                   1.4.3      2023-12-10 [1] RSPM #>  digest                 0.6.39     2025-11-19 [1] RSPM #>  doParallel             1.0.17     2022-02-07 [1] RSPM #>  dplyr                * 1.1.4      2023-11-17 [1] RSPM #>  evaluate               1.0.5      2025-08-27 [1] RSPM #>  farver                 2.1.2      2024-05-13 [1] RSPM #>  fastmap                1.2.0      2024-05-15 [1] RSPM #>  foreach                1.5.2      2022-02-02 [1] RSPM #>  Formula                1.2-5      2023-02-24 [1] RSPM #>  fs                     1.6.6      2025-04-12 [1] RSPM #>  future                 1.68.0     2025-11-17 [1] RSPM #>  future.apply           1.20.0     2025-06-06 [1] RSPM #>  generics               0.1.4      2025-05-09 [1] RSPM #>  GenomicRanges          1.62.0     2025-10-29 [1] Bioconduc~ #>  GEOquery               2.78.0     2025-10-29 [1] Bioconduc~ #>  ggplot2              * 4.0.1      2025-11-14 [1] RSPM #>  ggpubr                 0.6.2      2025-10-17 [1] RSPM #>  ggsignif               0.6.4      2022-10-13 [1] RSPM #>  glmnet                 4.1-10     2025-07-17 [1] RSPM #>  globals                0.18.0     2025-05-08 [1] RSPM #>  glue                   1.8.0      2024-09-30 [1] RSPM #>  gower                  1.0.2      2024-12-17 [1] RSPM #>  graph                  1.88.0     2025-10-29 [1] Bioconduc~ #>  gridExtra              2.3        2017-09-09 [1] RSPM #>  gtable                 0.3.6      2024-10-25 [1] RSPM #>  hardhat                1.4.2      2025-08-20 [1] RSPM #>  hms                    1.1.4      2025-10-17 [1] RSPM #>  htmltools              0.5.8.1    2024-04-04 [1] RSPM #>  htmlwidgets            1.6.4      2023-12-06 [1] RSPM #>  iml                    0.11.4     2025-02-24 [1] RSPM #>  ipred                  0.9-15     2024-07-18 [1] RSPM #>  IRanges                2.44.0     2025-10-29 [1] Bioconduc~ #>  iterators              1.0.14     2022-02-05 [1] RSPM #>  jquerylib              0.1.4      2021-04-26 [1] RSPM #>  jsonlite               2.0.0      2025-03-27 [1] RSPM #>  km.ci                  0.5-6      2022-04-06 [1] RSPM #>  KMsurv                 0.1-6      2025-05-20 [1] RSPM #>  knitr                  1.50       2025-03-16 [1] RSPM #>  labeling               0.4.3      2023-08-29 [1] RSPM #>  lattice                0.22-7     2025-04-02 [3] CRAN (R 4.5.2) #>  lava                   1.8.2      2025-10-30 [1] RSPM #>  lifecycle              1.0.4      2023-11-07 [1] RSPM #>  lime                   0.5.3      2022-08-19 [1] RSPM #>  limma                  3.66.0     2025-10-29 [1] Bioconduc~ #>  listenv                0.10.0     2025-11-02 [1] RSPM #>  lubridate              1.9.4      2024-12-08 [1] RSPM #>  magrittr               2.0.4      2025-09-12 [1] RSPM #>  MASS                   7.3-65     2025-02-28 [3] CRAN (R 4.5.2) #>  Matrix                 1.7-4      2025-08-28 [3] CRAN (R 4.5.2) #>  MatrixGenerics         1.22.0     2025-10-29 [1] Bioconduc~ #>  matrixStats            1.5.0      2025-01-07 [1] RSPM #>  Metrics                0.1.4      2018-07-09 [1] RSPM #>  ModelMetrics           1.2.2.2    2020-03-17 [1] RSPM #>  mvtnorm                1.3-3      2025-01-10 [1] RSPM #>  nlme                   3.1-168    2025-03-31 [3] CRAN (R 4.5.2) #>  nnet                   7.3-20     2025-01-01 [3] CRAN (R 4.5.2) #>  numDeriv               2016.8-1.1 2019-06-06 [1] RSPM #>  parallelly             1.45.1     2025-07-24 [1] RSPM #>  patchwork              1.3.2      2025-08-25 [1] RSPM #>  pec                    2025.06.24 2025-07-24 [1] RSPM #>  pheatmap             * 1.0.13     2025-06-05 [1] RSPM #>  pillar                 1.11.1     2025-09-17 [1] RSPM #>  pkgconfig              2.0.3      2019-09-22 [1] RSPM #>  pkgdown                2.2.0      2025-11-06 [1] any (@2.2.0) #>  plyr                   1.8.9      2023-10-02 [1] RSPM #>  pROC                   1.19.0.1   2025-07-31 [1] RSPM #>  prodlim                2025.04.28 2025-04-28 [1] RSPM #>  purrr                  1.2.0      2025-11-04 [1] RSPM #>  R6                     2.6.1      2025-02-15 [1] RSPM #>  ragg                   1.5.0      2025-09-02 [1] RSPM #>  randomForest           4.7-1.2    2024-09-22 [1] RSPM #>  RBGL                   1.86.0     2025-10-29 [1] Bioconduc~ #>  RColorBrewer           1.1-3      2022-04-03 [1] RSPM #>  Rcpp                   1.1.0      2025-07-02 [1] RSPM #>  RcppParallel           5.1.11-1   2025-08-27 [1] RSPM #>  RCurl                  1.98-1.17  2025-03-22 [1] RSPM #>  readr                  2.1.6      2025-11-14 [1] RSPM #>  recipes                1.3.1      2025-05-21 [1] RSPM #>  rentrez                1.2.4      2025-06-11 [1] RSPM #>  reshape2               1.4.5      2025-11-12 [1] RSPM #>  rlang                  1.1.6      2025-04-11 [1] RSPM #>  rmarkdown              2.30       2025-09-28 [1] RSPM #>  rpart                  4.1.24     2025-01-07 [3] CRAN (R 4.5.2) #>  rstatix                0.7.3      2025-10-18 [1] RSPM #>  RUnit                  0.4.33.1   2025-06-17 [1] RSPM #>  S4Arrays               1.10.1     2025-12-01 [1] Bioconduc~ #>  S4Vectors              0.48.0     2025-10-29 [1] Bioconduc~ #>  S7                     0.2.1      2025-11-14 [1] RSPM #>  sass                   0.4.10     2025-04-11 [1] RSPM #>  scales                 1.4.0      2025-04-24 [1] RSPM #>  Seqinfo                1.0.0      2025-10-29 [1] Bioconduc~ #>  sessioninfo          * 1.2.3      2025-02-05 [1] RSPM #>  shape                  1.4.6.1    2024-02-23 [1] RSPM #>  SparseArray            1.10.4     2025-12-01 [1] Bioconduc~ #>  statmod                1.5.1      2025-10-09 [1] RSPM #>  stringi                1.8.7      2025-03-27 [1] RSPM #>  stringr                1.6.0      2025-11-04 [1] RSPM #>  SummarizedExperiment   1.40.0     2025-10-29 [1] Bioconduc~ #>  survival               3.8-3      2024-12-17 [3] CRAN (R 4.5.2) #>  survminer              0.5.1      2025-09-02 [1] RSPM #>  survMisc               0.5.6      2022-04-07 [1] RSPM #>  systemfonts            1.3.1      2025-10-01 [1] RSPM #>  textshaping            1.0.4      2025-10-10 [1] RSPM #>  tibble                 3.3.0      2025-06-08 [1] RSPM #>  tidyr                  1.3.1      2024-01-24 [1] RSPM #>  tidyselect             1.2.1      2024-03-11 [1] RSPM #>  timechange             0.3.0      2024-01-18 [1] RSPM #>  timeDate               4051.111   2025-10-17 [1] RSPM #>  timereg                2.0.7      2025-08-18 [1] RSPM #>  timeROC                0.4        2019-12-18 [1] RSPM #>  tzdb                   0.5.0      2025-03-15 [1] RSPM #>  vctrs                  0.6.5      2023-12-01 [1] RSPM #>  withr                  3.0.2      2024-10-28 [1] RSPM #>  xfun                   0.54       2025-10-30 [1] RSPM #>  xgboost                1.7.11.1   2025-05-15 [1] RSPM #>  XML                    3.99-0.20  2025-11-08 [1] RSPM #>  xml2                   1.5.1      2025-12-01 [1] RSPM #>  xtable                 1.8-4      2019-04-21 [1] RSPM #>  XVector                0.50.0     2025-10-29 [1] Bioconduc~ #>  yaml                   2.3.11     2025-11-28 [1] RSPM #>  zoo                    1.8-14     2025-04-10 [1] RSPM #>  #>  [1] /home/runner/work/_temp/Library #>  [2] /opt/R/4.5.2/lib/R/site-library #>  [3] /opt/R/4.5.2/lib/R/library #>  * ── Packages attached to the search path. #>  #> ──────────────────────────────────────────────────────────────────────────────"},{"path":"https://danymukesha.github.io/BioGA/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Dany Mukesha. Author, maintainer.","code":""},{"path":"https://danymukesha.github.io/BioGA/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Mukesha D (2024). “Scalable Interpretable Genetic Algorithm Framework High-Throughput Genomic Data.” Zenodo. doi:10.5281/zenodo.15801072, https://doi.org/10.5281/zenodo.15801072. Mukesha D (2024). BioGA: Bioinformatics Genetic Algorithm (BioGA). doi:10.18129/B9.bioc.BioGA, R package version 1.0.0, https://danymukesha.github.io/BioGA/.","code":"@Article{,   title = {Scalable and Interpretable Genetic Algorithm Framework for High-Throughput Genomic Data},   author = {Dany Mukesha},   year = {2024},   journal = {Zenodo},   doi = {10.5281/zenodo.15801072},   url = {https://doi.org/10.5281/zenodo.15801072}, } @Manual{,   title = {BioGA: Bioinformatics Genetic Algorithm (BioGA)},   author = {Dany Mukesha},   year = {2024},   journal = {Bioconductor},   note = {R package version 1.0.0},   doi = {10.18129/B9.bioc.BioGA},   url = {https://danymukesha.github.io/BioGA/}, }"},{"path":"https://danymukesha.github.io/BioGA/index.html","id":"bioga-","dir":"","previous_headings":"","what":"Bioinformatics Genetic Algorithm (BioGA)","title":"Bioinformatics Genetic Algorithm (BioGA)","text":"BioGA package provides set functions genetic algorithm optimization adapted analyzing high throughput genomic data. functions implemented C++ improved speed efficiency, easy--use interface use within R.","code":""},{"path":"https://danymukesha.github.io/BioGA/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Bioinformatics Genetic Algorithm (BioGA)","text":"install package, start R (preferably version “4.4”) enter: can also install package directly GitHub using devtools package:","code":"if (!require(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\")  # The following initializes usage of Bioc devel BiocManager::install(version='devel')  BiocManager::install(pkgs = \"BioGA\", version = \"devel\", force = TRUE) devtools::install_github(\"danymukesha/BioGA\")"},{"path":"https://danymukesha.github.io/BioGA/reference/BioGA-package.html","id":null,"dir":"Reference","previous_headings":"","what":"BioGA: Bioinformatics Genetic Algorithm (BioGA) — BioGA-package","title":"BioGA: Bioinformatics Genetic Algorithm (BioGA) — BioGA-package","text":"Genetic algorithm class optimization algorithms inspired process natural selection genetics. package allows users analyze optimize high throughput genomic data using genetic algorithms. functions provided implemented C++ improved speed efficiency, easy--use interface use within R.","code":""},{"path":[]},{"path":"https://danymukesha.github.io/BioGA/reference/BioGA-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"BioGA: Bioinformatics Genetic Algorithm (BioGA) — BioGA-package","text":"Maintainer: Dany Mukesha danymukesha@gmail.com (ORCID)","code":""},{"path":"https://danymukesha.github.io/BioGA/reference/bioga_main_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Main genetic algorithm loop for genomic data optimization — bioga_main_cpp","title":"Main genetic algorithm loop for genomic data optimization — bioga_main_cpp","text":"Main genetic algorithm loop genomic data optimization","code":""},{"path":"https://danymukesha.github.io/BioGA/reference/bioga_main_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Main genetic algorithm loop for genomic data optimization — bioga_main_cpp","text":"","code":"bioga_main_cpp(   genomic_data,   population_size,   num_generations,   crossover_rate,   eta_c,   mutation_rate,   num_parents,   num_offspring,   num_to_replace,   weights,   seed = NULL,   clusters = NULL,   network = NULL )"},{"path":"https://danymukesha.github.io/BioGA/reference/bioga_main_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Main genetic algorithm loop for genomic data optimization — bioga_main_cpp","text":"genomic_data Numeric matrix genomic data (rows: genes, columns: samples). population_size Number individuals population. num_generations Number generations run. crossover_rate Probability crossover. eta_c SBX distribution index (default: 20.0). mutation_rate Base probability mutation. num_parents Number parents select per generation. num_offspring Number offspring generate per generation. num_to_replace Number individuals replace per generation. weights Numeric vector weights multi-objective fitness. seed Optional random seed reproducibility. clusters Optional vector gene cluster assignments. network Optional matrix gene network constraints.","code":""},{"path":"https://danymukesha.github.io/BioGA/reference/bioga_main_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Main genetic algorithm loop for genomic data optimization — bioga_main_cpp","text":"List containing final population fitness scores.","code":""},{"path":"https://danymukesha.github.io/BioGA/reference/bioga_main_cpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Main genetic algorithm loop for genomic data optimization — bioga_main_cpp","text":"","code":"genomic_data <- matrix(rnorm(100), nrow = 10, ncol = 10) result <- BioGA::bioga_main_cpp(genomic_data, population_size = 50, num_generations = 10,         crossover_rate = 0.9, eta_c = 20.0, mutation_rate = 0.1,         num_parents = 20, num_offspring = 20, num_to_replace = 10,         weights = c(1.0, 0.5), seed = 123) #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 1 #> Current front size: 0 #> Warning: No non-dominated individuals found.     Using full population for selection. #> Current front size: 1 #> Current front size: 1"},{"path":"https://danymukesha.github.io/BioGA/reference/crossover_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to perform simulated binary crossover (SBX) — crossover_cpp","title":"Function to perform simulated binary crossover (SBX) — crossover_cpp","text":"Function perform simulated binary crossover (SBX)","code":""},{"path":"https://danymukesha.github.io/BioGA/reference/crossover_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to perform simulated binary crossover (SBX) — crossover_cpp","text":"","code":"crossover_cpp(   selected_parents,   offspring_size,   crossover_rate = 0.9,   eta_c = 20 )"},{"path":"https://danymukesha.github.io/BioGA/reference/crossover_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to perform simulated binary crossover (SBX) — crossover_cpp","text":"selected_parents Numeric matrix selected individuals. offspring_size Number offspring generate. crossover_rate Probability crossover (default: 0.9). eta_c SBX distribution index (default: 20.0).","code":""},{"path":"https://danymukesha.github.io/BioGA/reference/crossover_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to perform simulated binary crossover (SBX) — crossover_cpp","text":"Numeric matrix offspring.","code":""},{"path":"https://danymukesha.github.io/BioGA/reference/crossover_cpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to perform simulated binary crossover (SBX) — crossover_cpp","text":"","code":"genomic_data <- matrix(rnorm(100), nrow = 10, ncol = 10) population <- BioGA::initialize_population_cpp(genomic_data,  population_size = 5) fitness <- BioGA::evaluate_fitness_cpp(genomic_data, population,  c(1.0, 0.5)) selected_parents <- BioGA::selection_cpp(population, fitness,  num_parents = 2) #> Current front size: 1 BioGA::crossover_cpp(selected_parents, offspring_size = 2) #>            [,1]      [,2]       [,3]       [,4]       [,5]      [,6]     [,7] #> [1,] -0.8366399 0.4341165 -0.5434423 -0.1996363 -0.9343821 0.7124227 1.201867 #> [2,] -0.8366399 0.4341165 -0.5434423 -0.1996363 -0.9343821 0.7124227 1.201867 #>           [,8]      [,9]      [,10] #> [1,] 0.2879157 0.1691907 -0.9783576 #> [2,] 0.2879157 0.1691907 -0.9783576"},{"path":"https://danymukesha.github.io/BioGA/reference/evaluate_fitness_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to evaluate fitness using genomic data with multi-objective support — evaluate_fitness_cpp","title":"Function to evaluate fitness using genomic data with multi-objective support — evaluate_fitness_cpp","text":"Function evaluate fitness using genomic data multi-objective support","code":""},{"path":"https://danymukesha.github.io/BioGA/reference/evaluate_fitness_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to evaluate fitness using genomic data with multi-objective support — evaluate_fitness_cpp","text":"","code":"evaluate_fitness_cpp(genomic_data, population, weights)"},{"path":"https://danymukesha.github.io/BioGA/reference/evaluate_fitness_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to evaluate fitness using genomic data with multi-objective support — evaluate_fitness_cpp","text":"genomic_data Numeric matrix genomic data (rows: genes, columns: samples). population Numeric matrix representing population individuals. weights Numeric vector weights multi-objective fitness (e.g., expression difference, sparsity).","code":""},{"path":"https://danymukesha.github.io/BioGA/reference/evaluate_fitness_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to evaluate fitness using genomic data with multi-objective support — evaluate_fitness_cpp","text":"Numeric matrix fitness scores (columns: objectives, rows: individuals).","code":""},{"path":"https://danymukesha.github.io/BioGA/reference/evaluate_fitness_cpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to evaluate fitness using genomic data with multi-objective support — evaluate_fitness_cpp","text":"","code":"genomic_data <- matrix(rnorm(100), nrow = 10, ncol = 10) population <- BioGA::initialize_population_cpp(genomic_data,  population_size = 5) weights <- c(1.0, 0.5) # Weight for expression difference and sparsity BioGA::evaluate_fitness_cpp(genomic_data, population, weights) #>          [,1] [,2] #> [1,] 174.1882  0.5 #> [2,] 185.6447  0.5 #> [3,] 282.9144  0.5 #> [4,] 260.4805  0.5 #> [5,] 239.6672  0.5"},{"path":"https://danymukesha.github.io/BioGA/reference/initialize_population_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to initialize population with optional gene clustering — initialize_population_cpp","title":"Function to initialize population with optional gene clustering — initialize_population_cpp","text":"Function initialize population optional gene clustering","code":""},{"path":"https://danymukesha.github.io/BioGA/reference/initialize_population_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to initialize population with optional gene clustering — initialize_population_cpp","text":"","code":"initialize_population_cpp(   genomic_data,   population_size,   seed = NULL,   clusters = NULL )"},{"path":"https://danymukesha.github.io/BioGA/reference/initialize_population_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to initialize population with optional gene clustering — initialize_population_cpp","text":"genomic_data Numeric matrix genomic data (rows: genes, columns: samples). population_size Number individuals population. seed Optional random seed reproducibility. clusters Optional vector gene cluster assignments.","code":""},{"path":"https://danymukesha.github.io/BioGA/reference/initialize_population_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to initialize population with optional gene clustering — initialize_population_cpp","text":"Numeric matrix initialized population.","code":""},{"path":"https://danymukesha.github.io/BioGA/reference/initialize_population_cpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to initialize population with optional gene clustering — initialize_population_cpp","text":"","code":"genomic_data <- matrix(rnorm(100), nrow = 10, ncol = 10) BioGA::initialize_population_cpp(genomic_data, population_size = 5,  seed = 123) #>            [,1]       [,2]      [,3]        [,4]       [,5]        [,6] #> [1,]  0.6644805 -0.3501541 0.2189152  0.07439935  0.3548044 -0.04733266 #> [2,] -0.3383459  0.5950387 0.3774680  0.27211081  2.5017651  0.65099328 #> [3,]  1.4264917  0.9967010 0.3774680 -0.06042597 -0.9732140  0.79157269 #> [4,] -0.3383459 -0.7006975 0.3774680 -0.08981425 -0.7795961  0.07504484 #> [5,] -0.6558381  0.5950387 0.2189152 -0.80241961  2.5017651  0.79416747 #>            [,7]       [,8]       [,9]      [,10] #> [1,] -0.9944350  1.2929929  1.0936361 -1.0047212 #> [2,] -0.3395090  0.9344820 -0.2306096  0.6982138 #> [3,] -0.9944350 -0.4153374  0.2909621 -0.3092672 #> [4,] -0.4927276 -0.5939900 -0.2306096 -0.0550220 #> [5,] -0.3395090 -1.3970639  0.2909621 -1.1124601"},{"path":"https://danymukesha.github.io/BioGA/reference/mutation_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to mutate offspring with adaptive mutation and network constraints — mutation_cpp","title":"Function to mutate offspring with adaptive mutation and network constraints — mutation_cpp","text":"Function mutate offspring adaptive mutation network constraints","code":""},{"path":"https://danymukesha.github.io/BioGA/reference/mutation_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to mutate offspring with adaptive mutation and network constraints — mutation_cpp","text":"","code":"mutation_cpp(   offspring,   mutation_rate,   iteration,   max_iterations,   network = NULL )"},{"path":"https://danymukesha.github.io/BioGA/reference/mutation_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to mutate offspring with adaptive mutation and network constraints — mutation_cpp","text":"offspring Numeric matrix offspring. mutation_rate Base probability mutation. iteration Current GA iteration adaptive mutation. max_iterations Maximum number GA iterations. network Optional matrix gene network constraints (rows: genes, cols: genes).","code":""},{"path":"https://danymukesha.github.io/BioGA/reference/mutation_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to mutate offspring with adaptive mutation and network constraints — mutation_cpp","text":"Numeric matrix mutated offspring.","code":""},{"path":"https://danymukesha.github.io/BioGA/reference/mutation_cpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to mutate offspring with adaptive mutation and network constraints — mutation_cpp","text":"","code":"genomic_data <- matrix(rnorm(100), nrow = 10, ncol = 10) population <- BioGA::initialize_population_cpp(genomic_data,  population_size = 5) fitness <- BioGA::evaluate_fitness_cpp(genomic_data, population,  c(1.0, 0.5)) selected_parents <- BioGA::selection_cpp(population, fitness,  num_parents = 2) #> Current front size: 1 offspring <- BioGA::crossover_cpp(selected_parents,  offspring_size = 2) BioGA::mutation_cpp(offspring, mutation_rate = 0.1, iteration = 1,  max_iterations = 100) #>          [,1]      [,2]      [,3]       [,4]      [,5]       [,6]      [,7] #> [1,] 1.096839 -0.640706 0.1813035 -0.1388914 0.3796395 -0.5023235 0.8951257 #> [2,] 1.096839 -0.640706 0.1813035 -0.1388914 0.3796395 -0.5259514 0.8951257 #>           [,8]      [,9]     [,10] #> [1,] 0.6443765 0.5194072 0.6886403 #> [2,] 0.6443765 0.5194072 0.6886403"},{"path":"https://danymukesha.github.io/BioGA/reference/replacement_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to replace population with elitism and diversity preservation — replacement_cpp","title":"Function to replace population with elitism and diversity preservation — replacement_cpp","text":"Function replace population elitism diversity preservation","code":""},{"path":"https://danymukesha.github.io/BioGA/reference/replacement_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to replace population with elitism and diversity preservation — replacement_cpp","text":"","code":"replacement_cpp(   population,   offspring,   fitness,   offspring_fitness,   num_to_replace )"},{"path":"https://danymukesha.github.io/BioGA/reference/replacement_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to replace population with elitism and diversity preservation — replacement_cpp","text":"population Numeric matrix individuals. offspring Numeric matrix offspring. fitness Numeric matrix population fitness scores. offspring_fitness Numeric matrix offspring fitness scores. num_to_replace Number individuals replace.","code":""},{"path":"https://danymukesha.github.io/BioGA/reference/replacement_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to replace population with elitism and diversity preservation — replacement_cpp","text":"Numeric matrix updated population.","code":""},{"path":"https://danymukesha.github.io/BioGA/reference/replacement_cpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to replace population with elitism and diversity preservation — replacement_cpp","text":"","code":"genomic_data <- matrix(rnorm(100), nrow = 10, ncol = 10) population <- BioGA::initialize_population_cpp(genomic_data,  population_size = 5) fitness <- BioGA::evaluate_fitness_cpp(genomic_data, population,  c(1.0, 0.5)) selected_parents <- BioGA::selection_cpp(population, fitness,  num_parents = 2) #> Current front size: 1 offspring <- BioGA::crossover_cpp(selected_parents, offspring_size = 2) offspring_fitness <- BioGA::evaluate_fitness_cpp(genomic_data, offspring,  c(1.0, 0.5)) BioGA::replacement_cpp(population, offspring, fitness, offspring_fitness,  num_to_replace = 1) #>            [,1]        [,2]       [,3]        [,4]       [,5]       [,6] #> [1,]  0.8846505 -0.49929202 -0.7886220 -0.09031959  0.6843094 -1.3952743 #> [2,]  1.6509075  0.48545998 -1.6674751 -0.50219872  1.4960607 -0.8953634 #> [3,]  0.8846505 -0.49929202 -0.7886220 -0.09031959  0.6843094 -1.3952743 #> [4,] -0.6111659  0.08920722 -0.5739735  0.61798582 -0.3439172 -0.8953634 #> [5,] -0.3887799 -1.53290200 -1.6674751 -0.32468591  0.3860266 -1.3952743 #>            [,7]        [,8]       [,9]       [,10] #> [1,]  0.8496430  0.05974994  0.1748027 -0.59461727 #> [2,]  0.1181445 -0.47624689  0.6007088  0.07455118 #> [3,]  0.8496430  0.05974994  0.1748027 -0.59461727 #> [4,] -1.3108015  0.13403865 -0.1009749 -1.75652740 #> [5,]  2.2930790  0.05974994  0.6007088 -0.71721816"},{"path":"https://danymukesha.github.io/BioGA/reference/selection_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to select individuals using NSGA-II non-dominated sorting — selection_cpp","title":"Function to select individuals using NSGA-II non-dominated sorting — selection_cpp","text":"Function select individuals using NSGA-II non-dominated sorting","code":""},{"path":"https://danymukesha.github.io/BioGA/reference/selection_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to select individuals using NSGA-II non-dominated sorting — selection_cpp","text":"","code":"selection_cpp(population, fitness, num_parents)"},{"path":"https://danymukesha.github.io/BioGA/reference/selection_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to select individuals using NSGA-II non-dominated sorting — selection_cpp","text":"population Numeric matrix individuals. fitness Numeric matrix fitness scores (columns: objectives). num_parents Number individuals select.","code":""},{"path":"https://danymukesha.github.io/BioGA/reference/selection_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to select individuals using NSGA-II non-dominated sorting — selection_cpp","text":"Numeric matrix selected individuals.","code":""},{"path":"https://danymukesha.github.io/BioGA/reference/selection_cpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to select individuals using NSGA-II non-dominated sorting — selection_cpp","text":"","code":"genomic_data <- matrix(rnorm(100), nrow = 10, ncol = 10) population <- BioGA::initialize_population_cpp(genomic_data,       population_size = 5) fitness <- BioGA::evaluate_fitness_cpp(genomic_data, population,       c(1.0, 0.5)) BioGA::selection_cpp(population, fitness, num_parents = 2) #> Current front size: 1 #>            [,1]      [,2]     [,3]      [,4]      [,5]       [,6]      [,7] #> [1,] -0.4356455 0.3461036 2.416773 -1.651049 0.1263159 0.05601673 0.5101325 #> [2,] -0.4356455 0.3461036 2.416773 -1.651049 0.1263159 0.05601673 0.5101325 #>            [,8]       [,9]     [,10] #> [1,] -0.4503386 -0.3497542 0.7564064 #> [2,] -0.4503386 -0.3497542 0.7564064"},{"path":"https://danymukesha.github.io/BioGA/news/index.html","id":"bioga-09917","dir":"Changelog","previous_headings":"","what":"BioGA 0.99.17","title":"BioGA 0.99.17","text":"Added: - Demo vignette BioGA. - Mathematical background vignette BioGA. Updated: - BioGA vignettes new examples explanations. - selection_cpp function improved performance bug fixes.","code":""},{"path":"https://danymukesha.github.io/BioGA/news/index.html","id":"bioga-09916","dir":"Changelog","previous_headings":"","what":"BioGA 0.99.16","title":"BioGA 0.99.16","text":"UPDATE: test_crossover_cpp test verifies dimensions, value ranges, new parameters. Changes: - Added tests new parameters (crossover_rate, eta_c). - Verified offspring values lie within parent ranges (due SBX). - Included edge case test single parent zero crossover rate. - Simplified error/warning checks. UPDATE: test_selection_cpp test checks dimensions, parent selection, compatibility multi-objective fitness. Changes: - Updated handle multi-objective fitness matrix. - Verified selected parents exact copies population rows. - Added edge case test single individual single objective. - Removed redundant fitness evaluation test (already covered evaluate_fitness_cpp). UPDATE: test_mutation_cpp test checks dimensions, mutation effects, new parameters. Changes: - Added tests new parameters (iteration, max_iterations, network). - Verified zero mutation rate preserves offspring. - Tested network constraints extreme cases (zero full constraints). - Simplified error/warning checks. UPDATE/ADDED: test_replacement_cpp test checks dimensions, elite preservation, diversity. Changes: - Added test new function signature (requires fitness matrices). - Verified elite preservation based first objective. - Included edge case test zero replacements. - Added checks dimensions error-free execution. UPDATE: test_initialize_population_cpp test checks dimensions, value validity, new parameters. Changes: - Added test seed parameter ensure reproducibility. - Included test clusters parameter verify correct initialization. - Maintained tests dimensions value validity. - Added edge case test minimal input. UPDATE: test_bioga_main_cpp {PROVISIONAL} New test file created verify main GA loop. Feature: - Tests output structure (list population fitness). - Verifies dimensions population fitness matrices. - Checks optional parameters (clusters, network). - Includes edge case test minimal input. Test Package (test-BioGA-package.R) Created new version test overall package integrity ensure functions exported correctly. Feature: - Tests package loading function exports. - Verifies complete GA workflow without errors. - Ensures compatibility optimized functions.","code":""},{"path":"https://danymukesha.github.io/BioGA/news/index.html","id":"bioga-09915","dir":"Changelog","previous_headings":"","what":"BioGA 0.99.15","title":"BioGA 0.99.15","text":"UPDATE: test_evaluate_fitness_cpp test checks dimensions, values, error-free execution. Changes: Updated test new matrix output (multiple objectives). Added checks non-negative fitness values (appropriate expression difference sparsity). Included edge case test minimal input. Removed redundant tryCatch simplified error/warning checks.","code":""},{"path":"https://danymukesha.github.io/BioGA/news/index.html","id":"bioga-09914","dir":"Changelog","previous_headings":"","what":"BioGA 0.99.14","title":"BioGA 0.99.14","text":"Commit -m “New Feature - Main GA Loop” adding main GA loop function integrates components supports multi-objective optimization parallelization. Features: Integrates optimized components cohesive GA loop. Supports multi-objective optimization, gene networks, clustering. Returns final population fitness scores analysis.","code":""},{"path":"https://danymukesha.github.io/BioGA/news/index.html","id":"bioga-09913","dir":"Changelog","previous_headings":"","what":"BioGA 0.99.13","title":"BioGA 0.99.13","text":"Commit -m “Optimized initialize_population.cpp” Improvements: Add option biologically informed initialization using gene clusters. Improve random seed handling reproducibility. Changes: Added optional random seed reproducibility. Included support gene clustering initialize biologically relevant populations. Improved code readability documentation.","code":""},{"path":"https://danymukesha.github.io/BioGA/news/index.html","id":"bioga-09912","dir":"Changelog","previous_headings":"","what":"BioGA 0.99.12","title":"BioGA 0.99.12","text":"Commit -m “Optimized replacement.cpp” indentation adjustments","code":""},{"path":"https://danymukesha.github.io/BioGA/news/index.html","id":"bioga-09911","dir":"Changelog","previous_headings":"","what":"BioGA 0.99.11","title":"BioGA 0.99.11","text":"Commit -m “Optimized replacement.cpp” Improvements: Implement elitism preserve best individuals. Add diversity-based replacement avoid premature convergence. Changes: Added elitism preserve best individual. Included diversity-based replacement maintain population diversity. Updated use multi-objective fitness matrix.","code":""},{"path":"https://danymukesha.github.io/BioGA/news/index.html","id":"bioga-09910","dir":"Changelog","previous_headings":"","what":"BioGA 0.99.10","title":"BioGA 0.99.10","text":"Commit -m “Optimized mutation.cpp” Improvements: Add adaptive mutation rate based iteration fitness stagnation. Incorporate gene network constraints (placeholder user-provided network). Changes: Added adaptive mutation rate based iteration progress. Included optional gene network constraints ensure biologically relevant mutations. Maintained compatibility existing functionality.","code":""},{"path":"https://danymukesha.github.io/BioGA/news/index.html","id":"bioga-0999","dir":"Changelog","previous_headings":"","what":"BioGA 0.99.9","title":"BioGA 0.99.9","text":"Commit -m “Optimized selection.cpp” Improvements: Implement NSGA-II non-dominated sorting multi-objective optimization. Add tournament selection better diversity. Changes: Implemented NSGA-II non-dominated sorting multi-objective selection. Added tournament selection maintain diversity. Updated handle multi-objective fitness matrix.","code":""},{"path":"https://danymukesha.github.io/BioGA/news/index.html","id":"bioga-0998","dir":"Changelog","previous_headings":"","what":"BioGA 0.99.8","title":"BioGA 0.99.8","text":"Commit -m “Optimized crossover.cpp” ” Improvements: Implement simulated binary crossover (SBX) better exploration. Add adaptive crossover rate based population diversity. Changes: Replaced simple averaging SBX crossover better exploration. Added adaptive crossover rate based population diversity. Included parameters crossover rate distribution index.","code":""},{"path":"https://danymukesha.github.io/BioGA/news/index.html","id":"bioga-0997","dir":"Changelog","previous_headings":"","what":"BioGA 0.99.7","title":"BioGA 0.99.7","text":"Commit -m “Optimized evaluate_fitness.cpp” Improvements: Add multi-objective fitness evaluation (e.g., minimize expression difference maximize gene sparsity). Use vectorized operations faster computation. Add parallelization RcppParallel large datasets. Changes: Added multi-objective support (expression difference sparsity). Used RcppParallel parallel computation. Returned matrix fitness scores objective. Added weights parameter flexible objective prioritization.","code":""},{"path":"https://danymukesha.github.io/BioGA/news/index.html","id":"bioga-0996","dir":"Changelog","previous_headings":"","what":"BioGA 0.99.6","title":"BioGA 0.99.6","text":"add authors date vignettes? R version less 4.4","code":""},{"path":[]},{"path":"https://danymukesha.github.io/BioGA/news/index.html","id":"bioga-0994","dir":"Changelog","previous_headings":"","what":"BioGA 0.99.4","title":"BioGA 0.99.4","text":"Fixed added updates requested Bioconductor Peer review","code":""},{"path":[]},{"path":"https://danymukesha.github.io/BioGA/news/index.html","id":"bioga-0992","dir":"Changelog","previous_headings":"","what":"BioGA 0.99.2","title":"BioGA 0.99.2","text":"Fixed ERROR: System files ‘BioGA.Rproj’ found Git tracked.","code":""},{"path":[]},{"path":"https://danymukesha.github.io/BioGA/news/index.html","id":"bioga-0990","dir":"Changelog","previous_headings":"","what":"BioGA 0.99.0","title":"BioGA 0.99.0","text":"Added NEWS.md file track changes package.","code":""}]
